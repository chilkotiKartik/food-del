'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var toolkit = require('@reduxjs/toolkit');
var React = require('react');
var reactRedux = require('react-redux');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var produce = require('immer');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _typeof = require('@babel/runtime/helpers/typeof');
var toPath = require('lodash/toPath');
var clone = require('lodash/clone');
var _extends = require('@babel/runtime/helpers/extends');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var produce__default = /*#__PURE__*/_interopDefaultLegacy(produce);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var toPath__default = /*#__PURE__*/_interopDefaultLegacy(toPath);
var clone__default = /*#__PURE__*/_interopDefaultLegacy(clone);
var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);

var getSlice = function getSlice(store, slice) {
  return store[slice];
};

var getSliceHistory = function getSliceHistory(store, slice) {
  return getSlice(store, slice).history;
};

var getSlicePresent = function getSlicePresent(store, slice) {
  return getSliceHistory(store, slice).present;
};

var getBatch = function getBatch(state) {
  return state.batch;
};

var getBatchConfiguration = function getBatchConfiguration(state) {
  return getBatch(state).configuration;
};

var getTreeSlice = function getTreeSlice(store) {
  return store.tree;
};

var getTreeHistory = function getTreeHistory(store) {
  return getSliceHistory(store, 'tree');
};

var getTree = function getTree(store) {
  return getSlicePresent(store, 'tree');
};

var getTransfer = function getTransfer(store) {
  return store.transfer;
};

// import {original} from "immer";
function proxy(reducer) {
  return function (state, action) {
    var present = state.history.present;
    reducer(present, action);
  };
}

produce.enablePatches(); // Lazy accumulates changes 
// for given reducer in 
// patches array.

function accumulator(reducer) {
  return function (state, action) {
    var _state$batch$patches;

    var present = state.history.present;

    var _produceWithPatches = produce.produceWithPatches(present, function (draft) {
      reducer(draft, action);
    }),
        _produceWithPatches2 = _slicedToArray__default['default'](_produceWithPatches, 2),
        patches = _produceWithPatches2[1]; // State mutations


    state.batch.past = state.batch.past || produce__default['default'](produce.original(state.history.present), function () {});

    (_state$batch$patches = state.batch.patches).push.apply(_state$batch$patches, _toConsumableArray__default['default'](patches));

    proxy(reducer)(state, action);
  };
}

function batched$1(reducer) {
  return function (state, action) {
    accumulator(reducer)(state, action);
  };
}

produce.enablePatches();
var creator = toolkit.createAction('commitHistory');
function commitHistory$1(state, action) {
  var batch = state.batch;
  var past = batch.past;
  var patches = batch.patches;

  var _produceWithPatches = produce.produceWithPatches(past, function (draft) {
    produce.applyPatches(draft, patches);
  }),
      _produceWithPatches2 = _slicedToArray__default['default'](_produceWithPatches, 3),
      redo = _produceWithPatches2[1],
      undo = _produceWithPatches2[2];

  var version = state.history.version;
  var historyLimit = state.configuration.historyLimit;
  var limitExceeded = version + 1 > historyLimit; // State mutations

  state.batch.patches = [];
  state.batch.past = null;
  if (patches.length === 0) return;
  if (!redo || redo.length === 0) return;
  state.history.timeline.length = state.history.version;

  if (limitExceeded) {
    state.history.timeline.shift();
  }

  state.history.timeline.push({
    undo: undo,
    redo: redo
  });
  state.history.version = state.history.timeline.length;
}

function unbatched$1(reducer) {
  return function (state, action) {
    creator(); // Commit any batched actions 
    // beforehand.

    commitHistory$1(state); // Execute reducer with given 
    // action. Accumulate patches 
    // for reducer.

    accumulator(reducer)(state, action); // Immediatly commit accumulated
    // patches afterwards.

    commitHistory$1(state);
  };
}

function signer(reducer) {
  return function (state, action) {
    creator(); // State mutations
    // Commit (sign) any batched 
    // actions.

    commitHistory$1(state);
    reducer(state, action);
  };
}

function unrecorded$1(reducer) {
  return function (state, action) {
    proxy(reducer)(state, action);
  };
}

// Selectors expect to receive
// whole versioned slice.
var getCanUndo = function getCanUndo(state) {
  return (// History has previous
    state.history.version !== 0 || // Batch has elements
    state.batch.patches.length > 0
  );
};

var getCanRedo = function getCanRedo(state) {
  return (// History has next
    state.history.version !== state.history.timeline.length
  );
};

produce.enablePatches();
function redoHistory$1(state, action) {
  var history = state.history;
  var version = history.version;
  var canRedo = getCanRedo(state); // Do nothing if cannot redo

  if (!canRedo) {
    return;
  } // Redo history
  else if (canRedo) {
      var timeline = history.timeline;
      var redo = timeline[version].redo;
      state.history.version += 1;
      state.history.present = produce.applyPatches(state.history.present, redo);
    }
}

produce.enablePatches();
function undoHistory$1(state, action) {
  var history = state.history;
  var version = history.version;
  var canUndo = getCanUndo(state); // Do nothing if cannot undo

  if (!canUndo) {
    return;
  } // Undo history
  else if (canUndo) {
      var timeline = history.timeline;
      var undo = timeline[version - 1].undo;
      state.history.version -= 1;
      state.history.present = produce.applyPatches(state.history.present, undo);
    }
}

function restartHistory$1(state) {
  // State mutations
  state.history.version = 0;
  state.history.timeline = [];
  state.batch.patches = [];
  state.batch.past = null;
}

function configureHistory(state, action) {
  var configuration = action.payload.configuration; // State mutations

  state.configuration.historyLimit = configuration.historyLimit;
}

function configureBatchHistory(state, action) {
  var configuration = action.payload.configuration; // State mutations

  state.batch.configuration.batchTimeLimit = configuration.historyBatchTimeLimit;
  state.batch.configuration.batchTime = configuration.historyBatchTime;
}

function isFunction$1(fn) {
  return typeof fn === 'function';
}

function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$h(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$h(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var commitReducers = {
  commitHistory: commitHistory$1
};
var historyReducers = {
  redoHistory: redoHistory$1,
  undoHistory: undoHistory$1,
  restartHistory: restartHistory$1,
  configureHistory: configureHistory,
  configureBatchHistory: configureBatchHistory
};
var createVersionedState = function createVersionedState(_ref) {
  var initialState = _ref.initialState,
      _ref$initialTimeline = _ref.initialTimeline,
      initialTimeline = _ref$initialTimeline === void 0 ? [] : _ref$initialTimeline,
      _ref$initialVersion = _ref.initialVersion,
      initialVersion = _ref$initialVersion === void 0 ? 0 : _ref$initialVersion,
      _ref$initialBatchTime = _ref.initialBatchTime,
      initialBatchTime = _ref$initialBatchTime === void 0 ? 3000 : _ref$initialBatchTime,
      _ref$initialBatchTime2 = _ref.initialBatchTimeLimit,
      initialBatchTimeLimit = _ref$initialBatchTime2 === void 0 ? 9000 : _ref$initialBatchTime2,
      _ref$initialHistoryLi = _ref.initialHistoryLimit,
      initialHistoryLimit = _ref$initialHistoryLi === void 0 ? 9999999 : _ref$initialHistoryLi;
  // Build slice with passed
  // and fallback data.
  var history = {
    version: initialVersion,
    present: initialState,
    timeline: initialTimeline
  };
  var timer = {
    batchTime: initialBatchTime,
    batchTimeLimit: initialBatchTimeLimit
  };
  var batch = {
    patches: [],
    configuration: timer,
    past: null
  };
  var configuration = {
    historyLimit: initialHistoryLimit
  };
  var versionedState = {
    history: history,
    batch: batch,
    configuration: configuration
  };
  return versionedState;
};

var createVersionedSlice = function createVersionedSlice(_ref2) {
  var name = _ref2.name,
      reducers = _ref2.reducers,
      extraReducers = _ref2.extraReducers,
      initialState = _ref2.initialState,
      initialTimeline = _ref2.initialTimeline,
      initialVersion = _ref2.initialVersion,
      initialBatchTime = _ref2.initialBatchTime,
      initialBatchTimeLimit = _ref2.initialBatchTimeLimit,
      initialHistoryLimit = _ref2.initialHistoryLimit;
  var versionedState = createVersionedState({
    initialState: initialState,
    initialBatchTime: initialBatchTime,
    initialBatchTimeLimit: initialBatchTimeLimit,
    initialHistoryLimit: initialHistoryLimit,
    initialTimeline: initialTimeline,
    initialVersion: initialVersion
  });
  var completeReducers = Object.entries(reducers).reduce(function (completeReducers, _ref3) {
    var _ref4 = _slicedToArray__default['default'](_ref3, 2),
        reducer_name = _ref4[0],
        reducer = _ref4[1];

    function withEnhancers(reducer) {
      var reducerFn = isFunction$1(reducer) ? reducer : reducer.reducer;

      for (var _len = arguments.length, enhancers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        enhancers[_key - 1] = arguments[_key];
      }

      var reducerEnhanced = enhancers.reduce(function (reducer, enhancer) {
        return enhancer(reducer);
      }, reducerFn);
      return isFunction$1(reducer) ? reducerEnhanced : _objectSpread$h(_objectSpread$h({}, reducer), {}, {
        reducer: reducerEnhanced
      });
    }

    var batched_name = "".concat(reducer_name, "/batched");
    var unbatched_name = "".concat(reducer_name, "/unbatched");
    var unrecorder_name = "".concat(reducer_name, "/unrecorded");
    completeReducers[batched_name] = withEnhancers(reducer, batched$1);
    completeReducers[unbatched_name] = withEnhancers(reducer, unbatched$1);
    completeReducers[unrecorder_name] = withEnhancers(reducer, unrecorded$1); // Raw reducer, as it would have 
    // been returned by normal
    // createSlice function. Behaviour
    // is implemeted because this function
    // is supposed to be a wrapper, so 
    // there are should be no changes to
    // root createSlice function in params
    // or return values.

    completeReducers[reducer_name] = reducer;
    return completeReducers;
  }, {});
  var signedHistoryReducers = Object.entries(historyReducers).reduce(function (reducers, _ref5) {
    var _ref6 = _slicedToArray__default['default'](_ref5, 2),
        type = _ref6[0],
        reducer = _ref6[1];

    reducers[type] = signer(reducer);
    return reducers;
  }, {});

  var versionedReducers = _objectSpread$h(_objectSpread$h(_objectSpread$h({}, completeReducers), commitReducers), signedHistoryReducers);

  var slice = toolkit.createSlice({
    name: name,
    initialState: versionedState,
    reducers: versionedReducers,
    extraReducers: extraReducers
  });
  var initialExtra = {
    batched: {},
    unbatched: {},
    unrecorded: {}
  };
  var extraActions = Object.entries(slice.actions).reduce(function (extraActions, _ref7) {
    var _ref8 = _slicedToArray__default['default'](_ref7, 2),
        actionType = _ref8[0],
        action = _ref8[1];

    var typeSplit = actionType.split('/').reverse();

    var _typeSplit = _slicedToArray__default['default'](typeSplit, 2),
        batch = _typeSplit[0],
        type = _typeSplit[1];

    if (extraActions[batch]) {
      extraActions[batch][type] = action;
    }

    return extraActions;
  }, initialExtra);
  slice.extraActions = extraActions;
  return slice;
};

var isInteger = function isInteger(obj) {
  return String(Math.floor(Number(obj))) === obj;
};
var isNumber = function isNumber(obj) {
  return !Number.isNaN(Number.parseFloat(obj));
};
var parseNumber = function parseNumber(obj) {
  return Number.parseFloat(obj);
};

function isFunction(fn) {
  return typeof fn === 'function';
}
function identity(arg) {
  return arg;
}

/*
 * Functions below taken from Formik source.
 * Acknowledgement made here as well.
*/

var isObject = function isObject(obj) {
  return obj !== null && _typeof__default['default'](obj) === 'object';
};
var getIn = function getIn(obj, key, fallback) {
  var p = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var path = toPath__default['default'](key);

  while (obj && p < path.length) {
    obj = obj[path[p++]];
  }

  return obj === undefined ? fallback : obj;
};
/**
 * Deeply set a value from in object via it's path. If the value at `path`
 * has changed, return a shallow copy of obj with `value` set at `path`.
 * If `value` has not changed, return the original `obj`.
 *
 * Existing objects / arrays along `path` are also shallow copied. Sibling
 * objects along path retain the same internal js reference. Since new
 * objects / arrays are only created along `path`, we can test if anything
 * changed in a nested structure by comparing the object's reference in
 * the old and new object, similar to how russian doll cache invalidation
 * works.
 *
 * In earlier versions of this function, which used cloneDeep, there were
 * issues whereby settings a nested value would mutate the parent
 * instead of creating a new object. `clone` avoids that bug making a
 * shallow copy of the objects along the update path
 * so no object is mutated in place.
 *
 * Before changing this function, please read through the following
 * discussions.
 *
 * @see https://github.com/developit/linkstate
 * @see https://github.com/jaredpalmer/formik/pull/123
 */

var setIn = function setIn(obj, path, value) {
  var res = clone__default['default'](obj); // this keeps inheritance when obj is a class

  var resVal = res;
  var i = 0;
  var pathArray = toPath__default['default'](path);

  for (; i < pathArray.length - 1; i++) {
    var currentPath = pathArray[i];
    var currentObj = getIn(obj, pathArray.slice(0, i + 1));

    if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {
      resVal = resVal[currentPath] = clone__default['default'](currentObj);
    } else {
      var nextPath = pathArray[i + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  } // Return original object if new value is the same as current


  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
    return obj;
  }

  if (value === undefined) {
    delete resVal[pathArray[i]];
  } else {
    resVal[pathArray[i]] = value;
  } // If the path array has a single element, the loop did not run.
  // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.


  if (i === 0 && value === undefined) {
    delete res[pathArray[i]];
  }

  return res;
};
function isDefined(object) {
  return object !== undefined && object !== null;
}
function keys(object) {
  return Object.keys(object);
}
function values(object) {
  return Object.values(object);
}
// two objects.
// Mutates Target object.

function deepMerge(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (!sources.length) return target;
  var source = sources.shift();

  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach(function (key) {
      if (isObject(source[key])) {
        if (!(key in target)) Object.assign(target, _defineProperty__default['default']({}, key, source[key]));else if (isFunction(target[key])) target[key] = function () {
          return deepMerge(target[key].apply(target, arguments), source[key]);
        };else target[key] = deepMerge(target[key], source[key]);
      } else if (isFunction(source[key])) {
        if (!(key in target)) Object.assign(target, _defineProperty__default['default']({}, key, source[key]));else if (isFunction(target[key])) target[key] = function () {
          return deepMerge(target[key].apply(target, arguments), source[key].apply(source, arguments));
        };else target[key] = function () {
          return deepMerge(target[key], source[key].apply(source, arguments));
        };
      } else {
        Object.assign(target, _defineProperty__default['default']({}, key, source[key]));
      }
    });
  }

  return deepMerge.apply(void 0, [target].concat(sources));
}

function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$g(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$g(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Branch = /*#__PURE__*/function () {
  function Branch(root) {
    var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck__default['default'](this, Branch);

    // Root should always be node
    // Cannot be another branch.
    this.root = root;
    this.children = children;
  }

  _createClass__default['default'](Branch, [{
    key: "with_child",
    value: function with_child(child) {
      var children = [].concat(_toConsumableArray__default['default'](this.children), [child]);
      return new Branch(this.root, children);
    }
  }]);

  return Branch;
}();

var Item = /*#__PURE__*/function () {
  function Item(detail, meta, indexes, indexes_list) {
    _classCallCheck__default['default'](this, Item);

    this.detail = detail;
    this.meta = meta || {};
    this.indexes = indexes || [];
    this.indexes_list = indexes_list || [];
  }

  _createClass__default['default'](Item, [{
    key: "with_meta",
    value: function with_meta(meta) {
      return new Item(this.detail, meta, this.indexes, this.indexes_list);
    }
  }, {
    key: "with_index",
    value: function with_index() {
      for (var _len = arguments.length, indexes = new Array(_len), _key = 0; _key < _len; _key++) {
        indexes[_key] = arguments[_key];
      }

      return new Item(this.detail, this.meta, [].concat(_toConsumableArray__default['default'](this.indexes), indexes), this.indexes_list);
    }
  }, {
    key: "with_index_list",
    value: function with_index_list() {
      for (var _len2 = arguments.length, indexes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        indexes[_key2] = arguments[_key2];
      }

      return new Item(this.detail, this.meta, this.indexes, [].concat(_toConsumableArray__default['default'](this.indexes_list), indexes));
    }
  }]);

  return Item;
}();

function isBranch(branch) {
  return branch instanceof Branch;
} // Proxy API function

function branch(root) {
  return new Branch(root);
}
function isItem(item) {
  return item instanceof Item;
} // Proxy API function

function item(detail) {
  return new Item(detail);
}
function normalizeBranch(branch) {
  function mergeRootToBranch(branch, rootToMerge) {
    branch.root = rootToMerge.id; // Merge

    return mergeItemToBranch(branch, rootToMerge);
  }

  function mergeNodeToBranch(branch, nodeToMerge) {
    // Establish parent-child relations
    nodeToMerge.node.parentId = branch.root;
    branch.byIds[branch.root].childIds.push(nodeToMerge.id); // Merge

    return mergeItemToBranch(branch, nodeToMerge);
  }

  function mergeItemToBranch(branch, itemToMerge) {
    // Merge
    branch.byIds[itemToMerge.id] = itemToMerge.node;
    branch.meta[itemToMerge.id] = itemToMerge.meta;
    itemToMerge.index.forEach(function (index) {
      branch.index[index] = itemToMerge.id;
    });
    itemToMerge.index_list.forEach(function (index) {
      var index_list = branch.index_list[index] || [];
      branch.index_list[index] = [].concat(_toConsumableArray__default['default'](index_list), [itemToMerge.id]);
    });
    return branch;
  }

  function mergeBranchToBranch(branch, branchToMerge) {
    // Establish parent-child relations
    branchToMerge.byIds[branchToMerge.root].parentId = branch.root;
    branch.byIds[branch.root].childIds.push(branchToMerge.root); // Merge

    keys(branchToMerge.byIds).forEach(function (id) {
      branch.byIds[id] = branchToMerge.byIds[id];
    });
    keys(branchToMerge.meta).forEach(function (id) {
      branch.meta[id] = branchToMerge.meta[id];
    });
    keys(branchToMerge.index).forEach(function (index) {
      branch.index[index] = branchToMerge.index[index];
    });
    keys(branchToMerge.index_list).forEach(function (index) {
      var index_list = branch.index_list[index] || [];
      branch.index_list[index] = [].concat(_toConsumableArray__default['default'](index_list), _toConsumableArray__default['default'](branchToMerge.index_list[index]));
    });
    return branch;
  }

  var treeInitial = {
    root: null,
    byIds: {},
    meta: {},
    index: {},
    index_list: {}
  };
  if (!branch.root) return treeInitial;
  var root = normalizeItem(branch.root);
  var treeWithRoot = mergeRootToBranch(treeInitial, root);
  var nodes = branch.children.filter(isItem);
  var treeWithNodes = nodes.reduce(function (tree, node) {
    var normal_node = normalizeItem(node);
    return mergeNodeToBranch(tree, normal_node);
  }, treeWithRoot);
  var branches = branch.children.filter(isBranch);
  var treeWithBranches = branches.reduce(function (tree, branch) {
    var normal_branch = normalizeBranch(branch);
    return mergeBranchToBranch(tree, normal_branch);
  }, treeWithNodes);
  return treeWithBranches;
}
function normalizeItem(item) {
  var auto_id = toolkit.nanoid();
  var forced_id = item.detail.__id__;
  var id = forced_id || auto_id;
  var node = {
    id: id,
    type: item.detail.type || null,
    props: item.detail.props || {},
    childIds: item.detail.childIds || [],
    parentId: item.detail.parentId || null
  };

  var meta = _objectSpread$g({
    id: id
  }, item.meta);

  var index = item.indexes;
  var index_list = item.indexes_list;
  return {
    id: id,
    node: node,
    meta: meta,
    index: index,
    index_list: index_list
  };
}
function plainBranch(branch) {
  return isBranch(branch) ? normalizeBranch(branch) : branch;
}

// Action will have payload containing
// complete tree to use as state. 
function replaceTree(state, action) {
  var tree = action.payload.tree; // State mutations

  state.root = tree.root;
  state.byIds = tree.byIds;
  state.meta = tree.meta;
  state.index = tree.index;
  state.index_list = tree.index_list;
}

var reducer$l = {
  reducer: replaceTree
};

var getTreeFromHistory = function getTreeFromHistory(state) {
  return state.present;
}; // Direct selectors


var getNodeById = function getNodeById(state, id) {
  return state.byIds[id];
};

var getNodeByFilter = function getNodeByFilter(state, filter) {
  return values(state.byIds).find(filter);
};

var getNodeByFinder = function getNodeByFinder(state, finder) {
  return getNodeById(state, finder(state));
};

var getNodeByIndex = function getNodeByIndex(state, index) {
  return state.byIds[state.index[index]];
};

var getRootNode = function getRootNode(state) {
  return getNodeById(state, state.root);
};

var getParentNode = function getParentNode(state, id) {
  return getNodeById(state, getNodeById(state, id) && getNodeById(state, id).parentId);
};

var getMetaById = function getMetaById(state, id) {
  return state.meta[id];
}; // Computed multi-selectors


var getMultipleById = function getMultipleById(state) {
  for (var _len = arguments.length, id = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    id[_key - 1] = arguments[_key];
  }

  return id.reduce(function (list, id) {
    list[id] = getNodeById(state, id);
    return list;
  }, {});
};

var getMultipleByFilter = function getMultipleByFilter(state, filter) {
  var byIds = state.byIds;
  var ids = keys(byIds).reduce(function (list, id) {
    if (filter(byIds[id])) list.push(id);
    return list;
  }, []);
  return getMultipleById.apply(void 0, [state].concat(_toConsumableArray__default['default'](ids)));
};

var getMultipleByFinder = function getMultipleByFinder(state, finder) {
  var ids = finder(state);
  return getMultipleById.apply(void 0, [state].concat(_toConsumableArray__default['default'](ids)));
};

var getMultipleByIndex = function getMultipleByIndex(state, index) {
  var ids = state.index_list[index] || [];
  return getMultipleById.apply(void 0, [state].concat(_toConsumableArray__default['default'](ids)));
};

var getParentsById = function getParentsById(state, id) {
  var parentIds = [];
  var parent = getParentNode(state, id);

  while (parent) {
    parentIds = [].concat(_toConsumableArray__default['default'](parentIds), [parent.id]);
    parent = getParentNode(state, parent.id);
  }

  return getMultipleById.apply(void 0, [state].concat(_toConsumableArray__default['default'](parentIds)));
};

var getDirectChildrenById = function getDirectChildrenById(state, id) {
  var node = getNodeById(state, id);
  var childIds = node.childIds;
  return getMultipleById.apply(void 0, [state].concat(_toConsumableArray__default['default'](childIds)));
};

var getChildrenById = function getChildrenById(state, id) {
  var childrenIds = includeChildren(id);

  function includeChildren(id) {
    var childrenIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var node = getNodeById(state, id);
    return node.childIds.reduce(function (children, id) {
      var childrenIds = [].concat(_toConsumableArray__default['default'](children), [id]);
      return includeChildren(id, childrenIds);
    }, childrenIds);
  }

  return getMultipleById.apply(void 0, [state].concat(_toConsumableArray__default['default'](childrenIds)));
};

var getMultipleMetaById = function getMultipleMetaById(state) {
  for (var _len2 = arguments.length, id = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    id[_key2 - 1] = arguments[_key2];
  }

  var nodes = getMultipleById.apply(void 0, [state].concat(id));
  var nodesIds = keys(nodes);
  return nodesIds.reduce(function (meta, id) {
    meta[id] = getMetaById(state, id);
    return meta;
  }, {});
}; // Computed selectors for indexes


var getIndexesForId = function getIndexesForId(state, id) {
  var indexedID = keys(state.index).filter(function (index) {
    return state.index[index] === id;
  });
  var indexedListID = keys(state.index_list).filter(function (index) {
    return state.index_list[index].includes(id);
  }); // Sort to be able to compare

  return [].concat(_toConsumableArray__default['default'](indexedID), _toConsumableArray__default['default'](indexedListID)).sort();
};

var getMultipleIndexesForId = function getMultipleIndexesForId(state) {
  for (var _len3 = arguments.length, id = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    id[_key3 - 1] = arguments[_key3];
  }

  var nodes = getMultipleById.apply(void 0, [state].concat(id));
  var nodesIds = keys(nodes);
  return nodesIds.reduce(function (indexes, id) {
    indexes[id] = getIndexesForId(state, id);
    return indexes;
  }, {});
};

function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$f(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
// branch to create. Branch will have 
// root, panel, transfer reference
// id nodes and a dictionary containing
// branch nodes data.

function createNode(state, action) {
  var _action$payload = action.payload,
      node = _action$payload.node,
      targetId = _action$payload.targetId,
      position = _action$payload.position;
  var rootId = node.root;
  var root = node.byIds[rootId];
  var rootParentId = targetId;
  var target = getNodeById(state, targetId);
  var targetChildIds = target.childIds;
  var insertPos = isDefined(position) ? position : targetChildIds.length; // State mutations (Order is important)

  Object.entries(node.byIds).forEach(function (_ref) {
    var _ref2 = _slicedToArray__default['default'](_ref, 2),
        id = _ref2[0],
        v = _ref2[1];

    state.byIds[id] = v;
  });
  state.byIds[targetId].childIds.splice(insertPos, 0, rootId);
  state.byIds[rootId] = _objectSpread$f(_objectSpread$f({}, root), {}, {
    parentId: rootParentId
  });
}

var reducer$k = {
  reducer: createNode
};

// reference id to child. Child id will 
// be deleted, cascading down the tree 
// deleting all subchilds under. Child id
// will be removed from parent's child list.

function deleteNode(state, action) {
  var id = action.payload.id;
  var nodesIds = [].concat(_toConsumableArray__default['default'](keys(getChildrenById(state, id))), [id]);
  var parent = getParentNode(state, id); // State mutations

  nodesIds.forEach(function (id) {
    if (state.root === id) state.root = null;
    delete state.byIds[id];
  });

  if (parent) {
    var childIndex = parent.childIds.indexOf(id);
    state.byIds[parent.id].childIds.splice(childIndex, 1);
  }
}

var reducer$j = {
  reducer: deleteNode
};

// reference id to action node
// (i.e. the node that will be moved)
// and shift position of 
// node relative to parent

function intershiftNode(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      absolute = _action$payload.absolute,
      relative = _action$payload.relative;
  var node = getNodeById(state, id);
  var parent = getNodeById(state, node.parentId);
  var parentChildIds = parent.childIds;
  var size = parentChildIds.length;
  var from = parentChildIds.indexOf(id);
  var insertPos = isDefined(absolute) ? absolute : isDefined(relative) ? from + relative : size; // State mutations

  state.byIds[parent.id].childIds.splice(from, 1);
  state.byIds[parent.id].childIds.splice(insertPos, 0, id);
}

var reducer$i = {
  reducer: intershiftNode
};

// branch to create. Branch will have 
// root, panel, transfer reference
// id nodes and a dictionary containing
// branch nodes data.

function moveNode(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      targetId = _action$payload.targetId,
      position = _action$payload.position;
  var parent = getParentNode(state, id);
  var target = getNodeById(state, targetId);
  var parentChildIds = parent.childIds;
  var from = parentChildIds.indexOf(id);
  var targetChildIds = target.childIds;
  var insertPos = isDefined(position) ? position : targetChildIds.length; // State mutations (Order is important)

  state.byIds[parent.id].childIds.splice(from, 1);
  state.byIds[targetId].childIds.splice(insertPos, 0, id);
  state.byIds[id].parentId = targetId;
}

var reducer$h = {
  reducer: moveNode
};

// reference id to node to update, and
// props to update.

function updateNode(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      _action$payload$props = _action$payload.props,
      props = _action$payload$props === void 0 ? {} : _action$payload$props; // State mutations

  deepMerge(state.byIds[id].props, props);
}

var reducer$g = {
  reducer: updateNode
};

// Action will have payload containing
// reference id to node to update, and
// rewrite props.
function rewriteNode(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      _action$payload$props = _action$payload.props,
      props = _action$payload$props === void 0 ? {} : _action$payload$props; // State mutations

  state.byIds[id].props = props;
}

var reducer$f = {
  reducer: rewriteNode
};

function createMeta(state, action) {
  var meta = action.payload.meta; // State mutation

  Object.entries(meta).map(function (_ref) {
    var _ref2 = _slicedToArray__default['default'](_ref, 2),
        id = _ref2[0],
        v = _ref2[1];

    state.meta[id] = v;
  });
}

var reducer$e = {
  reducer: createMeta
};

function deleteMeta(state, action) {
  var id = action.payload.id;
  var nodesIds = [].concat(_toConsumableArray__default['default'](keys(getChildrenById(state, id))), [id]); // State mutations

  nodesIds.forEach(function (id) {
    delete state.meta[id];
  });
}

var reducer$d = {
  reducer: deleteMeta
};

function updateMeta(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      _action$payload$meta = _action$payload.meta,
      meta = _action$payload$meta === void 0 ? {} : _action$payload$meta; // State mutations

  deepMerge(state.meta[id], meta);
}

var reducer$c = {
  reducer: updateMeta
};

function startIndex(state, action) {
  var _action$payload = action.payload,
      index = _action$payload.index,
      index_list = _action$payload.index_list; // State mutations

  Object.entries(index).forEach(function (_ref) {
    var _ref2 = _slicedToArray__default['default'](_ref, 2),
        name = _ref2[0],
        id = _ref2[1];

    state.index[name] = id;
  });
  Object.entries(index_list).forEach(function (_ref3) {
    var _ref4 = _slicedToArray__default['default'](_ref3, 2),
        name = _ref4[0],
        ids = _ref4[1];

    var past = state.index_list[name];
    if (past) ids.forEach(function (id) {
      return state.index_list[name].push(id);
    });
    if (!past) state.index_list[name] = ids;
  });
}

var reducer$b = {
  reducer: startIndex
};

// Used for state mutation
// inside reducers. 
function filterInPlace(a, condition, thisArg) {
  var j = 0;
  a.forEach(function (e, i) {
    if (condition.call(thisArg, e, i, a)) {
      if (i !== j) a[j] = e;
      j++;
    }
  });
  a.length = j;
  return a;
}

function deleteIndex(state, action) {
  var id = action.payload.id;
  var ids = [].concat(_toConsumableArray__default['default'](keys(getChildrenById(state, id))), [id]);
  var nodes = getMultipleById.apply(void 0, [state].concat(_toConsumableArray__default['default'](ids))); // State mutations

  Object.keys(state.index).forEach(function (index) {
    var indexID = state.index[index];
    var isIndex = nodes[indexID];
    if (isIndex) state.index[index] = null;
  });
  Object.keys(state.index_list).forEach(function (index) {
    var indexList = state.index_list[index];

    var isNotIndex = function isNotIndex(indexID) {
      return !nodes[indexID];
    };

    filterInPlace(indexList, isNotIndex);
  });
}

var reducer$a = {
  reducer: deleteIndex
};

function addIndex(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      name = _action$payload.name; // State mutations

  state.index[name] = id;
}

var reducer$9 = {
  reducer: addIndex
};

function removeIndex(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      name = _action$payload.name;
  var index = state.index[name];
  var isIndex = index && index === id; // State mutations

  if (isIndex) state.index[name] = null;
}

var reducer$8 = {
  reducer: removeIndex
};

function toggleIndex(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      name = _action$payload.name;
  var index = state.index[name];
  var isIndex = index && index === id; // State mutations

  if (isIndex) state.index[name] = null;
  if (!isIndex) state.index[name] = id;
}

var reducer$7 = {
  reducer: toggleIndex
};

function clearIndex(state, action) {
  var name = action.payload.name; // State mutations

  state.index[name] = null;
}

var reducer$6 = {
  reducer: clearIndex
};

function addListIndex(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      name = _action$payload.name; // State mutations

  state.index_list[name] = state.index_list[name] || [];
  state.index_list[name].push(id);
}

var reducer$5 = {
  reducer: addListIndex
};

function removeListIndex(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      name = _action$payload.name;
  var list = state.index_list[name];
  var position = list ? list.indexOf(id) : -1;
  var isIndex = position >= 0; // State mutations

  if (isIndex) state.index_list[name].splice(position, 1);
}

var reducer$4 = {
  reducer: removeListIndex
};

function toggleListIndex(state, action) {
  var _action$payload = action.payload,
      id = _action$payload.id,
      name = _action$payload.name;
  var list = state.index_list[name];
  var position = list ? list.indexOf(id) : -1;
  var isIndex = position >= 0; // State mutations

  if (isIndex) {
    state.index_list[name].splice(position, 1);
  }

  if (!isIndex) {
    state.index_list[name] = state.index_list[name] || [];
    state.index_list[name].push(id);
  }
}

var reducer$3 = {
  reducer: toggleListIndex
};

function clearListIndex(state, action) {
  var name = action.payload.name; // State mutations

  state.index_list[name] = [];
}

var reducer$2 = {
  reducer: clearListIndex
};

var reducers$1 = {
  createNode: reducer$k,
  deleteNode: reducer$j,
  intershiftNode: reducer$i,
  moveNode: reducer$h,
  replaceTree: reducer$l,
  rewriteNode: reducer$f,
  updateNode: reducer$g,
  createMeta: reducer$e,
  deleteMeta: reducer$d,
  updateMeta: reducer$c,
  createIndex: reducer$b,
  deleteIndex: reducer$a,
  addIndex: reducer$9,
  removeIndex: reducer$8,
  toggleIndex: reducer$7,
  clearIndex: reducer$6,
  addListIndex: reducer$5,
  removeListIndex: reducer$4,
  toggleListIndex: reducer$3,
  clearListIndex: reducer$2
};
var tree = createVersionedSlice({
  name: 'tree',
  reducers: reducers$1
});
var batched = tree.extraActions.batched;
var unbatched = tree.extraActions.unbatched;
var unrecorded = tree.extraActions.unrecorded;
var actions = tree.actions;
var createNodeBatched = batched.createNode,
    deleteNodeBatched = batched.deleteNode,
    intershiftNodeBatched = batched.intershiftNode,
    moveNodeBatched = batched.moveNode,
    updateNodeBatched = batched.updateNode,
    rewriteNodeBatched = batched.rewriteNode,
    createMetaBatched = batched.createMeta,
    deleteMetaBatched = batched.deleteMeta,
    updateMetaBatched = batched.updateMeta,
    createIndexBatched = batched.createIndex,
    deleteIndexBatched = batched.deleteIndex,
    addIndexBatched = batched.addIndex,
    removeIndexBatched = batched.removeIndex,
    toggleIndexBatched = batched.toggleIndex,
    clearIndexBatched = batched.clearIndex,
    addListIndexBatched = batched.addListIndex,
    removeListIndexBatched = batched.removeListIndex,
    toggleListIndexBatched = batched.toggleListIndex,
    clearListIndexBatched = batched.clearListIndex;
    batched.replaceTree;
unbatched.createNode;
    unbatched.deleteNode;
    var intershiftNodeUnbatched = unbatched.intershiftNode,
    moveNodeUnbatched = unbatched.moveNode,
    updateNodeUnbatched = unbatched.updateNode,
    rewriteNodeUnbatched = unbatched.rewriteNode;
    unbatched.createMeta;
    unbatched.deleteMeta;
    var updateMetaUnbatched = unbatched.updateMeta;
    unbatched.createIndex;
    unbatched.deleteIndex;
    var addIndexUnbatched = unbatched.addIndex,
    removeIndexUnbatched = unbatched.removeIndex,
    toggleIndexUnbatched = unbatched.toggleIndex,
    clearIndexUnbatched = unbatched.clearIndex,
    addListIndexUnbatched = unbatched.addListIndex,
    removeListIndexUnbatched = unbatched.removeListIndex,
    toggleListIndexUnbatched = unbatched.toggleListIndex,
    clearListIndexUnbatched = unbatched.clearListIndex;
    unbatched.replaceTree;
var createNodeUnrecorded = unrecorded.createNode,
    deleteNodeUnrecorded = unrecorded.deleteNode,
    intershiftNodeUnrecorded = unrecorded.intershiftNode,
    moveNodeUnrecorded = unrecorded.moveNode,
    updateNodeUnrecorded = unrecorded.updateNode,
    rewriteNodeUnrecorded = unrecorded.rewriteNode,
    createMetaUnrecorded = unrecorded.createMeta,
    deleteMetaUnrecorded = unrecorded.deleteMeta,
    updateMetaUnrecorded = unrecorded.updateMeta,
    createIndexUnrecorded = unrecorded.createIndex,
    deleteIndexUnrecorded = unrecorded.deleteIndex,
    addIndexUnrecorded = unrecorded.addIndex,
    removeIndexUnrecorded = unrecorded.removeIndex,
    toggleIndexUnrecorded = unrecorded.toggleIndex,
    clearIndexUnrecorded = unrecorded.clearIndex,
    addListIndexUnrecorded = unrecorded.addListIndex,
    removeListIndexUnrecorded = unrecorded.removeListIndex,
    toggleListIndexUnrecorded = unrecorded.toggleListIndex,
    clearListIndexUnrecorded = unrecorded.clearListIndex,
    replaceTreeUnrecorded = unrecorded.replaceTree;
var undoHistory = actions.undoHistory,
    redoHistory = actions.redoHistory,
    restartHistory = actions.restartHistory,
    commitHistory = actions.commitHistory;
    actions.configureHistory;
    actions.configureBatchHistory;

var Timer = /*#__PURE__*/function () {
  function Timer(timer) {
    _classCallCheck__default['default'](this, Timer);

    this.running = timer.running || false;
    this.timeout = null;
    this.latest = timer.latest;
    this.checkpoint = timer.checkpoint;
    this.start = timer.start;
  }

  _createClass__default['default'](Timer, [{
    key: "begin",
    value: function begin() {
      var now = Date.now();
      this.running = true;
      this.start = now;
      this.checkpoint = now;
      this.latest = now;
    }
  }, {
    key: "mark",
    value: function mark() {
      var now = Date.now();
      this.running = true;
      this.checkpoint = now;
      this.latest = now;
    }
  }, {
    key: "update",
    value: function update() {
      var now = Date.now();
      this.latest = now;
    }
  }, {
    key: "withHandlers",
    value: function withHandlers(handlers) {
      this.handlers = handlers;
    }
  }, {
    key: "getDifference",
    value: function getDifference() {
      return this.latest - this.checkpoint;
    }
  }, {
    key: "getShort",
    value: function getShort() {
      return this.latest - this.checkpoint;
    }
  }, {
    key: "getTotal",
    value: function getTotal() {
      var now = Date.now();
      return now - this.start;
    }
  }, {
    key: "getLong",
    value: function getLong() {
      var now = Date.now();
      return now - this.latest;
    }
  }, {
    key: "isRunning",
    value: function isRunning() {
      return this.running;
    }
  }, {
    key: "run",
    value: function run(configuration) {
      var _this = this;

      this.millis = configuration.batchTime;
      this.maxMillis = configuration.batchTimeLimit;
      this.begin();
      return new Promise(function (res, rej) {
        var finishLong = function finishLong() {
          return _this.finishLong();
        };

        _this.timeout = setTimeout(finishLong, _this.millis);

        var reject = function reject(reason) {
          rej(reason);
          clearTimeout(_this.timeout);
        };

        var resolve = function resolve(value) {
          res(value);
        };

        _this.withHandlers({
          resolve: resolve,
          reject: reject
        });
      });
    }
  }, {
    key: "finish",
    value: function finish() {
      var diff = this.getDifference();
      var total = this.getTotal();

      if (diff === 0 || total >= this.maxMillis) {
        this.running = false;
        this.timeout = null;
        this.handlers.resolve();
        return true;
      }

      return false;
    }
  }, {
    key: "finishLong",
    value: function finishLong() {
      var _this2 = this;

      if (this.finish()) return;
      var short = this.getShort();
      this.mark();

      var finishShort = function finishShort() {
        return _this2.finishShort();
      };

      this.timeout = setTimeout(finishShort, short);
    }
  }, {
    key: "finishShort",
    value: function finishShort() {
      var _this3 = this;

      if (this.finish()) return;
      var long = this.millis - this.getLong();
      this.mark();

      var finishLong = function finishLong() {
        return _this3.finishLong();
      };

      this.timeout = setTimeout(finishLong, long);
    }
  }, {
    key: "forceFinish",
    value: function forceFinish() {
      if (!this.running) return;
      this.handlers.resolve();
      this.running = false;
      this.timeout = null;
    }
  }, {
    key: "abort",
    value: function abort(reason) {
      if (!this.running) return;
      this.handlers.reject(reason);
      this.running = false;
      this.timeout = null;
    }
  }]);

  return Timer;
}();
function timer() {
  return new Timer({});
}

function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useTimer = function useTimer(_ref) {
  var _ref$initialOnStart = _ref.initialOnStart,
      initialOnStart = _ref$initialOnStart === void 0 ? function () {} : _ref$initialOnStart,
      _ref$initialOnUpate = _ref.initialOnUpate,
      initialOnUpate = _ref$initialOnUpate === void 0 ? function () {} : _ref$initialOnUpate,
      _ref$initialOnFinish = _ref.initialOnFinish,
      initialOnFinish = _ref$initialOnFinish === void 0 ? function () {} : _ref$initialOnFinish,
      configuration = _ref.configuration;

  var _useState = React.useState(timer()),
      _useState2 = _slicedToArray__default['default'](_useState, 1),
      timer$1 = _useState2[0];

  var _useState3 = React.useState(function () {
    return initialOnStart;
  }),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      onStart = _useState4[0],
      setOnStart = _useState4[1];

  var _useState5 = React.useState(function () {
    return initialOnUpate;
  }),
      _useState6 = _slicedToArray__default['default'](_useState5, 2),
      onUpdate = _useState6[0],
      setOnUpdate = _useState6[1];

  var _useState7 = React.useState(function () {
    return initialOnFinish;
  }),
      _useState8 = _slicedToArray__default['default'](_useState7, 2),
      onFinish = _useState8[0],
      setOnFinish = _useState8[1];

  var start = React.useCallback(function () {
    var done = function done() {
      onFinish();
    };

    var error = function error() {};

    timer$1.run(configuration).then(done).catch(error); // Call start handler

    onStart();
  }, [timer$1, onStart, onFinish, configuration]);
  var update = React.useCallback(function () {
    timer$1.update(); // Call update handler

    onUpdate();
  }, [timer$1, onUpdate]); // Imperative handler for
  // refreshing timer

  var refresh = React.useCallback(function () {
    var running = timer$1.running;
    if (running) update();else start();
  }, [timer$1, update, start]);
  var abort = React.useCallback(function () {
    timer$1.abort();
  }, [timer$1]); // Clean up effect

  React.useEffect(function () {
    return abort;
  }, [abort]);
  var utils = {
    refresh: refresh,
    abort: abort
  };
  var timerBag = {
    setOnStart: setOnStart,
    setOnUpdate: setOnUpdate,
    setOnFinish: setOnFinish
  };

  var bag = _objectSpread$e(_objectSpread$e({}, timerBag), utils);

  return bag;
};

var useBatcher = function useBatcher() {
  var selector = function selector(store) {
    return getBatchConfiguration(getTreeSlice(store));
  };

  var configuration = reactRedux.useSelector(selector);
  var dispatch = reactRedux.useDispatch();

  var initialOnFinish = function initialOnFinish() {
    dispatch(commitHistory({}));
  };

  var batcher = useTimer({
    initialOnFinish: initialOnFinish,
    configuration: configuration
  });
  return batcher;
};

var BuilderContext = /*#__PURE__*/React.createContext({
  batcher: {
    refresh: function refresh() {},
    abort: function abort() {}
  },
  events: {
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {}
  }
});

function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useEvents = function useEvents() {
  var listeners = React.useRef(new Map());
  var addEventListener = React.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var node = args[0],
        type = args[1],
        listener = args[2];
    var node_listeners = listeners.current.get(node) || {};
    var type_listeners = node_listeners[type] || [];
    var added_listeners = [].concat(_toConsumableArray__default['default'](type_listeners), [listener]);
    var updated_listeners = Object.assign({}, node_listeners, _defineProperty__default['default']({}, type, added_listeners));
    listeners.current.set(node, updated_listeners);
  }, []);
  var removeEventListener = React.useCallback(function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var node = args[0],
        type = args[1],
        listener = args[2];
    var node_listeners = listeners.current.get(node) || {};
    var type_listeners = node_listeners[type] || [];
    var removed_listeners = type_listeners.filter(function (type) {
      return type !== listener;
    });
    var updated_listeners = Object.assign({}, node_listeners, _defineProperty__default['default']({}, type, removed_listeners));
    listeners.current.set(node, updated_listeners);
  }, []);
  var utils = {
    addEventListener: addEventListener,
    removeEventListener: removeEventListener
  };
  var eventsBag = {
    listeners: listeners
  };

  var bag = _objectSpread$d(_objectSpread$d({}, eventsBag), utils);

  return bag;
};

function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useEventHelpers = function useEventHelpers() {
  function getEventClientCoords(event) {
    var x = isNumber(event.clientX) ? event.clientX : event.changedTouches ? event.changedTouches[0].clientX : event.touches && event.touches[0].clientX;
    var y = isNumber(event.clientY) ? event.clientY : event.changedTouches ? event.changedTouches[0].clientY : event.touches && event.touches[0].clientY;
    return [x, y];
  }

  function getEventPosition(event) {
    var coords = getEventClientCoords(event);

    var _coords = _slicedToArray__default['default'](coords, 2),
        eventX = _coords[0],
        eventY = _coords[1];

    var target = event.currentTarget;

    var _target$getBoundingCl = target.getBoundingClientRect(),
        top = _target$getBoundingCl.top,
        height = _target$getBoundingCl.height,
        left = _target$getBoundingCl.left,
        width = _target$getBoundingCl.width;

    var centerX = left + width / 2;
    var centerY = top + height / 2;
    return {
      top: centerY > eventY,
      bottom: centerY <= eventY,
      left: centerX > eventX,
      right: centerX <= eventX
    };
  }

  var helpersBag = {
    getEventClientCoords: getEventClientCoords,
    getEventPosition: getEventPosition
  };

  var bag = _objectSpread$c({}, helpersBag);

  return bag;
};

/*
 * These functions work with subset of store 
 * containing value of 'transfer' in store 
 * dictionary.

 * As such, they do not expect to receive
 * the whole store as their first argument,
 * but a value containing only the store's
 * value for 'transfer'
*/
var getTransferData = function getTransferData(state) {
  return state.data;
};

var getTransferMeta = function getTransferMeta(state) {
  return state.meta;
};

var getTransferType = function getTransferType(state) {
  return state.type;
};

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var DnDEvents = function DnDEvents(_ref) {
  var listeners = _ref.listeners;

  var selector = function selector(store) {
    return getTransfer(store);
  };

  var transfer = reactRedux.useSelector(selector);
  var data = getTransferData(transfer);
  var isTransfering = Boolean(data);
  var events = useEventHelpers();

  function mutateEventStopPropagation(event) {
    function stopPropagation() {
      event.__stopped = true;
    }

    function isPropagationStopped() {
      return event.__stopped;
    }

    Object.defineProperty(event, 'stopPropagation', {
      value: stopPropagation,
      configurable: true
    });
    Object.defineProperty(event, 'isPropagationStopped', {
      value: isPropagationStopped,
      configurable: true
    });
    Object.defineProperty(event, '__stopped', {
      value: false,
      configurable: true,
      writable: true
    });
    return event;
  }

  function mutateEventTarget(event, target) {
    Object.defineProperty(event, 'currentTarget', {
      value: target,
      configurable: true,
      writable: true
    });
    return event;
  } // An object to keep reference
  // of current entered element


  var insideOne = React.useRef(null); // An object to keep reference
  // of current entered elements

  var insideMultiple = React.useRef([]); // Heavy imperative code below.
  // Manages and implements logic
  // for drag and drop events.

  function getEventElements(event) {
    var _events$getEventClien = events.getEventClientCoords(event),
        _events$getEventClien2 = _slicedToArray__default['default'](_events$getEventClien, 2),
        x = _events$getEventClien2[0],
        y = _events$getEventClien2[1];

    return document.elementsFromPoint(x, y);
  }

  function getHandlers(element, type) {
    var handlerMap = listeners.get(element) || {};
    var handlers = handlerMap[type] || [];
    return handlers;
  }

  var getBubblingEventHandler = function getBubblingEventHandler(type) {
    return function (event) {
      mutateEventStopPropagation(event);
      var elements = getEventElements(event); // Loop through all elements
      // at event position and call 
      // handlers for elements that
      // have at least one attached.

      var _iterator = _createForOfIteratorHelper(elements),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var element = _step.value;
          if (event.isPropagationStopped()) break;
          var handlers = getHandlers(element, type);
          if (handlers.length === 0) continue;
          mutateEventTarget(event, element);
          handlers.forEach(function (handler) {
            return handler(event);
          });
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };
  };

  var getEnteringEventHandler = function getEnteringEventHandler(type) {
    return function (event) {
      return function (ref) {
        mutateEventStopPropagation(event);
        var elements = getEventElements(event);

        var _iterator2 = _createForOfIteratorHelper(elements),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var element = _step2.value;
            var handlers = getHandlers(element, type);
            if (handlers.length === 0) continue; // Element is equal to previously 
            // entered element. No action needed.

            if (ref.current === element) return;
            ref.current = element;
            if (event.isPropagationStopped()) return;
            mutateEventTarget(event, element); // Call handlers for element, which
            // was determined to be topmost
            // and was not topmost before.

            handlers.forEach(function (handler) {
              return handler(event);
            });
            return;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      };
    };
  };

  var getLeavingEventHandler = function getLeavingEventHandler(type) {
    return function () {
      for (var _len = arguments.length, sideTypes = new Array(_len), _key = 0; _key < _len; _key++) {
        sideTypes[_key] = arguments[_key];
      }

      return function (event) {
        return function (ref) {
          mutateEventStopPropagation(event);
          var elements = getEventElements(event);
          var inside = ref.current; // Cannot leave if there is not an
          // element which was previously 
          // entered

          if (!inside) return; // If there was an element in which
          // drag was inside of but is no
          // longer inside of it.

          var leaveOut = true;

          var _iterator3 = _createForOfIteratorHelper(elements),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var element = _step3.value;
              if (element != inside) continue;
              leaveOut = false;
              break;
            } // If there was an element in which
            // drag was inside of but there is
            // another element which also has
            // a side type listener.

          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          var leaveAnother = false;

          var _iterator4 = _createForOfIteratorHelper(elements),
              _step4;

          try {
            var _loop = function _loop() {
              var element = _step4.value;

              var find = function find(type) {
                return getHandlers(element, type).length > 0;
              };

              var hasHandlers = sideTypes.find(find);
              if (!hasHandlers) return "continue";
              if (element === inside) return "break";
              leaveAnother = true;
              return "break";
            };

            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _ret = _loop();

              if (_ret === "continue") continue;
              if (_ret === "break") break;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          if (!leaveOut && !leaveAnother) return;
          if (leaveOut) ref.current = null;
          if (event.isPropagationStopped()) return;
          var handlers = getHandlers(inside, type);
          if (handlers.length === 0) return;
          mutateEventTarget(event, inside);
          handlers.forEach(function (handler) {
            return handler(event);
          });
        };
      };
    };
  };

  var getInEventHandler = function getInEventHandler(type) {
    return function (event) {
      return function (ref) {
        mutateEventStopPropagation(event);
        var elements = getEventElements(event);
        var insideBefore = ref.current; // Call all type handlers for
        // elements that are events
        // position and were not in
        // previous event's position.

        var _iterator5 = _createForOfIteratorHelper(elements),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var element = _step5.value;
            if (event.isPropagationStopped()) break;
            var handlers = getHandlers(element, type);
            if (handlers.length === 0) continue;
            if (insideBefore.includes(element)) continue;
            mutateEventTarget(event, element);
            handlers.forEach(function (handler) {
              return handler(event);
            });
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        ref.current = elements;
      };
    };
  };

  var getOutEventHandler = function getOutEventHandler(type) {
    return function (event) {
      return function (ref) {
        mutateEventStopPropagation(event);
        var elements = getEventElements(event);
        var insideBefore = ref.current; // Call all type handlers for
        // elements that were in previous
        // event's position and are not 
        // in current event's position.

        var _iterator6 = _createForOfIteratorHelper(insideBefore),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var element = _step6.value;
            if (event.isPropagationStopped()) break;
            var handlers = getHandlers(element, type);
            if (handlers.length === 0) continue;
            if (elements.includes(element)) continue;
            mutateEventTarget(event, element);
            handlers.forEach(function (handler) {
              return handler(event);
            });
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      };
    };
  }; // eslint-disable-next-line


  function handleDrop(event) {
    getBubblingEventHandler('drop')(event);
  } // eslint-disable-next-line


  function handleDragOver(event) {
    getBubblingEventHandler('dragover')(event);
  } // eslint-disable-next-line


  function handleDragEnter(event) {
    getEnteringEventHandler('dragenter')(event)(insideOne);
  } // eslint-disable-next-line


  function handleDragLeave(event) {
    getLeavingEventHandler('dragleave')('dragenter')(event)(insideOne);
  } // eslint-disable-next-line


  function handleDragIn(event) {
    getInEventHandler('dragin')(event)(insideMultiple);
  } // eslint-disable-next-line


  function handleDragOut(event) {
    getOutEventHandler('dragout')(event)(insideMultiple);
  }

  React.useEffect(function () {
    if (!isTransfering) return;
    document.addEventListener('dragover', handleDragLeave);
    document.addEventListener('dragover', handleDragOut);
    document.addEventListener('dragover', handleDragIn);
    document.addEventListener('dragover', handleDragEnter);
    document.addEventListener('dragover', handleDragOver);
    document.addEventListener('drop', handleDrop);
    return function () {
      document.removeEventListener('dragover', handleDragLeave);
      document.removeEventListener('dragover', handleDragOut);
      document.removeEventListener('dragover', handleDragIn);
      document.removeEventListener('dragover', handleDragEnter);
      document.removeEventListener('dragover', handleDragOver);
      document.removeEventListener('drop', handleDrop);
    };
  }, [isTransfering, handleDragOver, handleDragEnter, handleDragLeave, handleDragIn, handleDragOut, handleDrop]);
  React.useEffect(function () {
    if (!isTransfering) return;
    document.addEventListener('touchmove', handleDragLeave);
    document.addEventListener('touchmove', handleDragOut);
    document.addEventListener('touchmove', handleDragIn);
    document.addEventListener('touchmove', handleDragEnter);
    document.addEventListener('touchmove', handleDragOver);
    document.addEventListener('touchend', handleDrop);
    return function () {
      document.removeEventListener('touchmove', handleDragLeave);
      document.removeEventListener('touchmove', handleDragOut);
      document.removeEventListener('touchmove', handleDragIn);
      document.removeEventListener('touchmove', handleDragEnter);
      document.removeEventListener('touchmove', handleDragOver);
      document.removeEventListener('touchend', handleDrop);
    };
  }, [isTransfering, handleDragOver, handleDragEnter, handleDragLeave, handleDragIn, handleDragOut, handleDrop]); // Cleanup insideOne
  // whenever isDragging
  // is set to false.

  React.useEffect(function () {
    if (isTransfering) return;
    insideOne.current = null;
  }, [isTransfering]); // Cleanup insideMultiple
  // whenever isDragging
  // is set to false.

  React.useEffect(function () {
    if (isTransfering) return;
    insideMultiple.current = [];
  }, [isTransfering]);
  return null;
};

var BuilderProvider = function BuilderProvider(_ref) {
  var children = _ref.children;
  var batcher = useBatcher();
  var refresh = batcher.refresh;
  var abort = batcher.abort;
  var events = useEvents();
  var listeners = events.listeners.current;
  var addEventListener = events.addEventListener;
  var removeEventListener = events.removeEventListener;
  var context = React.useMemo(function () {
    return {
      batcher: {
        refresh: refresh,
        abort: abort
      },
      events: {
        addEventListener: addEventListener,
        removeEventListener: removeEventListener
      }
    };
  }, [refresh, abort, addEventListener, removeEventListener]);
  return /*#__PURE__*/React__default['default'].createElement(BuilderContext.Provider, {
    value: context
  }, /*#__PURE__*/React__default['default'].createElement(DnDEvents, {
    listeners: listeners
  }), children);
};

// Initial preloaded state
// for transfer slice is defined
// here as the return value of
// below function.
// Will call function in createSlice.
// Will not call in configureStore to
// pass as preloadedState value.
// @see: https://redux.js.org/recipes/structuring-reducers/initializing-state
var preloadedTransfer = function preloadedTransfer() {
  return {
    data: null,
    meta: null,
    type: null
  };
};

function startTransfer$1(state, action) {
  var _action$payload = action.payload,
      data = _action$payload.data,
      meta = _action$payload.meta,
      type = _action$payload.type; // State mutations

  state.data = data;
  state.meta = meta;
  state.type = type;
}

var reducer$1 = {
  reducer: startTransfer$1
};

function endTransfer$1(state, action) {
  // State mutations
  state.data = null;
  state.meta = null;
  state.type = null;
}

var reducer = {
  reducer: endTransfer$1
};

var reducers = {
  startTransfer: reducer$1,
  endTransfer: reducer
};
var transfer = toolkit.createSlice({
  name: 'transfer',
  initialState: preloadedTransfer(),
  reducers: reducers
});
var _transfer$actions = transfer.actions,
    startTransfer = _transfer$actions.startTransfer,
    endTransfer = _transfer$actions.endTransfer;

var rootReducer = toolkit.combineReducers({
  tree: tree.reducer,
  transfer: transfer.reducer
});

// for tree slice is defined
// here as the return value of
// below function.
// Will call function in configureStore.
// Will not call in createSlice to pass 
// as initialState value.
// @see: https://redux.js.org/recipes/structuring-reducers/initializing-state

var preloadedTree = function preloadedTree(_ref) {
  var initialTree = _ref.initialTree,
      initialTimeline = _ref.initialTimeline,
      initialVersion = _ref.initialVersion,
      initialHistoryLimit = _ref.initialHistoryLimit,
      initialBatchTime = _ref.initialBatchTime,
      initialBatchTimeLimit = _ref.initialBatchTimeLimit;
  var initialState = initialTree // Convert passed 
  // initialTree to 
  // flat object, if any.
  ? plainBranch(initialTree) // Convert fallback 
  // initialTree to 
  // flat object.
  : plainBranch(branch());
  return createVersionedState({
    initialState: initialState,
    initialTimeline: initialTimeline,
    initialVersion: initialVersion,
    initialHistoryLimit: initialHistoryLimit,
    initialBatchTime: initialBatchTime,
    initialBatchTimeLimit: initialBatchTimeLimit
  });
};

var Builder = function Builder(_ref) {
  var initialTree = _ref.initialTree,
      initialTimeline = _ref.initialTimeline,
      initialVersion = _ref.initialVersion,
      initialHistoryLimit = _ref.initialHistoryLimit,
      initialBatchTime = _ref.initialBatchTime,
      initialBatchTimeLimit = _ref.initialBatchTimeLimit,
      children = _ref.children;
  var initialTreeSlice = preloadedTree({
    initialTree: initialTree,
    initialTimeline: initialTimeline,
    initialVersion: initialVersion,
    initialHistoryLimit: initialHistoryLimit,
    initialBatchTime: initialBatchTime,
    initialBatchTimeLimit: initialBatchTimeLimit
  }); // Builder component will most likely
  // be a sub-application, for which
  // having multiple stores is justified.
  // As mentioned from the Redux docs:
  // "Isolating a Redux app as a component 
  // in a bigger application, in which case 
  // you might want to create a store per 
  // root component instance".
  // @see: https://redux.js.org/faq/store-setup
  // Multiple Builder components, however,
  // cannot share any state between them.

  var initialStore = function initialStore() {
    return toolkit.configureStore({
      reducer: rootReducer,
      // Allow non-serializable data
      // to be passed down to view
      // components, such as functions.
      // Trade-offs include time-traveling
      // debug problems.
      middleware: [],
      // Configure initial store state
      // to received initialTree prop.
      // (This allows stuff like SSG
      // because no useEffect is 
      // required).
      preloadedState: {
        tree: initialTreeSlice
      }
    });
  };

  var _useState = React.useState(initialStore),
      _useState2 = _slicedToArray__default['default'](_useState, 1),
      store = _useState2[0];

  return /*#__PURE__*/React__default['default'].createElement(reactRedux.Provider, {
    store: store
  }, /*#__PURE__*/React__default['default'].createElement(BuilderProvider, null, children));
};

function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var selectById = function selectById(id) {
  return function (store) {
    return getNodeById(getTree(store), id);
  };
};

var selectByFilter = function selectByFilter(filter) {
  return function (store) {
    return getNodeByFilter(getTree(store), filter);
  };
};

var selectByFinder = function selectByFinder(finder) {
  return function (store) {
    return getNodeByFinder(getTree(store), finder);
  };
};

var selectByIndex = function selectByIndex(index) {
  return function (store) {
    return getNodeByIndex(getTree(store), index);
  };
};

var selectParent = function selectParent(id) {
  return function (store) {
    return getParentNode(getTree(store), id);
  };
};

var selectRoot = function selectRoot() {
  return function (store) {
    return getRootNode(getTree(store));
  };
};

var useCollector = function useCollector(_ref) {
  var _ref$selector = _ref.selector,
      selector = _ref$selector === void 0 ? function () {} : _ref$selector;
  var selectors = {
    selectById: selectById,
    selectByFilter: selectByFilter,
    selectByFinder: selectByFinder,
    selectByIndex: selectByIndex,
    selectParent: selectParent,
    selectRoot: selectRoot
  };
  var chosen = selector(selectors);
  var node = reactRedux.useSelector(chosen);
  var id = node && node.id;

  var metaSelector = function metaSelector(store) {
    return getMetaById(getTree(store), id);
  };

  var meta = reactRedux.useSelector(metaSelector);

  var indexSelector = function indexSelector(store) {
    return getIndexesForId(getTree(store), id);
  };

  var indexing = reactRedux.useSelector(indexSelector, reactRedux.shallowEqual);
  var handler = {
    get: function get(target, name) {
      return target.includes(name);
    }
  };
  var indexes = new Proxy(indexing, handler);
  var collectorBag = {
    node: node,
    meta: meta,
    indexes: indexes
  };

  var bag = _objectSpread$b({}, collectorBag);

  return bag;
};

var ViewContext = /*#__PURE__*/React.createContext();

var ViewProvider = function ViewProvider(_ref) {
  var view = _ref.view,
      children = _ref.children;
  return /*#__PURE__*/React__default['default'].createElement(ViewContext.Provider, {
    value: view
  }, children);
};

function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Node = function Node(_ref) {
  var id = _ref.id,
      view = _ref.view,
      shallow = _ref.shallow,
      _ref$childrenAs = _ref.childrenAs,
      childrenAs = _ref$childrenAs === void 0 ? Node : _ref$childrenAs,
      _ref$filterProps = _ref.filterProps,
      filterProps = _ref$filterProps === void 0 ? identity : _ref$filterProps,
      rest = _objectWithoutProperties__default['default'](_ref, ["id", "view", "shallow", "childrenAs", "filterProps"]);

  var selector = function selector(selectors) {
    return selectors.selectById(id);
  };

  var collected = useCollector({
    selector: selector
  });
  var node = collected.node;
  var type = node.type,
      props = node.props,
      childIds = node.childIds;
  var Resolved = view[type];
  var render = Boolean(Resolved);
  var Child = childrenAs;
  var propsAll = filterProps(_objectSpread$a(_objectSpread$a({}, props), rest)); // Render as resolved type, with 
  // props pass taken from tree props 
  // and render children as subtree
  // nodes.

  return render ? /*#__PURE__*/React__default['default'].createElement(Resolved, _extends__default['default']({}, propsAll, {
    id: node.id
  }), !shallow && childIds.length > 0 ? childIds.map(function (childId) {
    return /*#__PURE__*/React__default['default'].createElement(Child, _extends__default['default']({
      key: childId,
      id: childId,
      view: view,
      childrenAs: childrenAs,
      filterProps: filterProps
    }, rest));
  }) : []) : null;
};

/*
 * Facade component
 * for Node. 
*/

var Workspace = function Workspace(_ref) {
  var view = _ref.view;

  var selector = function selector(selectors) {
    return selectors.selectRoot();
  };

  var collected = useCollector({
    selector: selector
  });
  var node = collected.node;
  return node ? /*#__PURE__*/React__default['default'].createElement(ViewProvider, {
    view: view
  }, /*#__PURE__*/React__default['default'].createElement(Node, {
    id: node.id,
    view: view
  })) : null;
};

var Panel = function Panel(_ref) {
  var view = _ref.view;

  var selector = function selector(selectors) {
    return selectors.selectByIndex('panel');
  };

  var collected = useCollector({
    selector: selector
  });
  var node = collected.node || {};
  var type = node.type; // Render as resolved type, with 
  // props pass

  var Resolved = view[type];
  return Resolved ? /*#__PURE__*/React__default['default'].createElement(Resolved, {
    id: node.id
  }) : null;
};

var useShareRef = function useShareRef(ref) {
  var innerRef = React.useRef(ref && ref.current);
  React.useEffect(function () {
    if (!ref) {
      return;
    }

    if (typeof ref === 'function') {
      ref(innerRef.current);
      return;
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
};

var useBuilderContext = function useBuilderContext() {
  var context = React.useContext(BuilderContext);
  return context;
};

var useEventCallback = function useEventCallback(fn) {
  var callback = React.useRef(function () {
    throw new Error("\n            Cannot call an event \n            handler while rendering.\n        ");
  });
  callback.current = fn;
  var eventCb = React.useCallback(function () {
    return callback.current.apply(callback, arguments);
  }, []);
  return eventCb;
};

var DnDSource = /*#__PURE__*/React__default['default'].forwardRef(function DnDSource(_ref, ref) {
  var onDrop = _ref.onDrop,
      onDragEnd = _ref.onDragEnd,
      onDragOver = _ref.onDragOver,
      onDragStart = _ref.onDragStart,
      onDragEnter = _ref.onDragEnter,
      onDragLeave = _ref.onDragLeave,
      onDragIn = _ref.onDragIn,
      onDragOut = _ref.onDragOut,
      _ref$allowTouch = _ref.allowTouch,
      allowTouch = _ref$allowTouch === void 0 ? true : _ref$allowTouch,
      _ref$dragTouchTimeThr = _ref.dragTouchTimeThreshold,
      dragTouchTimeThreshold = _ref$dragTouchTimeThr === void 0 ? 200 : _ref$dragTouchTimeThr,
      _ref$isDragging = _ref.isDragging,
      isDragging = _ref$isDragging === void 0 ? false : _ref$isDragging,
      _ref$as = _ref.as,
      as = _ref$as === void 0 ? 'div' : _ref$as,
      rest = _objectWithoutProperties__default['default'](_ref, ["onDrop", "onDragEnd", "onDragOver", "onDragStart", "onDragEnter", "onDragLeave", "onDragIn", "onDragOut", "allowTouch", "dragTouchTimeThreshold", "isDragging", "as"]);

  // Use share ref to both forward
  // ref to parent component and
  // to use ref internally.
  var box = useShareRef(ref);
  var draggingBox = React.useRef(false);

  var _useState = React.useState(false),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      dragTouchActive = _useState2[0],
      setDragTouchActive = _useState2[1];

  var _useState3 = React.useState(null),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      dragTouchEvent = _useState4[0],
      setDragTouchEvent = _useState4[1]; // Warn client if box was not
  // attached to any DOM node
  // since it will cause problems.


  React.useEffect(function () {
    if (box.current) return;
    console.warn("\n            Could not attach ref\n            to underlying DOM node.\n            You should allow ref\n            forwarding in underlying\n            node to attach listeners.\n        ");
  }, [box]); // Events that go attached to 
  // this DOM node and trigger
  // react synthetic events.

  var handleDragStartMouse = useEventCallback(function (event) {
    event.stopPropagation(); // Do not start drag operation
    // if there is one currently 
    // running, (some mobile browsers
    // will trigger both drag start
    // and mouse down events for drag
    // start).

    if (dragTouchActive) return;
    reactRedux.batch(function () {
      return onDragStart(event);
    });
    draggingBox.current = true;
  });
  var handlePreDragStartTouch = useEventCallback(function (event) {
    event.stopPropagation(); // Do not start drag just yet. 
    // Set state to active to
    // let time threshold to 
    // determine whether or not
    // to trigger onDragStart.

    reactRedux.batch(function () {
      setDragTouchActive(true);
      setDragTouchEvent(event);
    });
  });
  var handleDragStartTouch = useEventCallback(function (event) {
    // Must re define currentTarget
    // because drag start touch is 
    // handled asynchronously.
    Object.defineProperty(event, 'currentTarget', {
      value: box.current,
      configurable: true
    });
    reactRedux.batch(function () {
      setDragTouchActive(false);
      setDragTouchEvent(null);
      onDragStart(event);
    });
    draggingBox.current = true;
  });
  var handleDragEndMouse = useEventCallback(function (event) {
    if (!draggingBox.current) return;
    reactRedux.batch(function () {
      return onDragEnd(event);
    });
    draggingBox.current = false;
  });
  var handleDragEndTouch = useEventCallback(function (event) {
    // Restart touch state in case
    // there is not an an ongoing drag 
    // operation for this Source 
    // component.
    if (!draggingBox.current) {
      reactRedux.batch(function () {
        setDragTouchActive(false);
        setDragTouchEvent(null);
      });
      return;
    } // Prevent default to prevent click
    // from occurring in case there
    // is an ongoing drag operation
    // for this Source component.


    if (event.cancelable) event.preventDefault(); // Handle drag end async to allow
    // other Source components to 
    // handle onDrop event before 
    // handling onDragEnd event for
    // this Source component.

    setTimeout(function () {
      // Must re define currentTarget
      // because drag end touch is 
      // handled asynchronously.
      Object.defineProperty(event, 'currentTarget', {
        value: box.current,
        configurable: true
      });
      reactRedux.batch(function () {
        return onDragEnd(event);
      });
      draggingBox.current = false;
    }, 0);
  }); // Must add handler to node
  // to allow drop and trigger
  // drag over animation to occur
  // in this component.

  var handleAllowDragOverMouse = useEventCallback(function (event) {
    event.preventDefault();
  }); // Effect to attach event
  // listeners to DOM node
  // in ref for HTML 5 API

  React.useEffect(function () {
    if (!box.current) return;
    var ref = box.current;
    if (onDragStart) ref.addEventListener('dragstart', handleDragStartMouse);
    if (onDragEnd) ref.addEventListener('dragend', handleDragEndMouse);
    if (onDrop) ref.addEventListener('dragover', handleAllowDragOverMouse);
    return function () {
      if (onDragStart && ref) ref.removeEventListener('dragstart', handleDragStartMouse);
      if (onDragEnd && ref) ref.removeEventListener('dragend', handleDragEndMouse);
      if (onDrop && ref) ref.removeEventListener('dragover', handleAllowDragOverMouse);
    };
  }, [box, onDragStart, onDragEnd, onDrop, handleDragStartMouse, handleDragEndMouse, handleAllowDragOverMouse]); // Effect to attach event
  // listeners to DOM node
  // in ref for Touch API

  React.useEffect(function () {
    if (!box.current || !allowTouch) return;
    var ref = box.current;
    if (onDragStart) ref.addEventListener('touchstart', handlePreDragStartTouch);
    if (onDragEnd) ref.addEventListener('touchend', handleDragEndTouch);
    return function () {
      if (onDragStart && ref) ref.removeEventListener('touchstart', handlePreDragStartTouch);
      if (onDragEnd && ref) ref.removeEventListener('touchend', handleDragEndTouch);
    };
  }, [box, allowTouch, onDragStart, onDragEnd, handlePreDragStartTouch, handleDragEndTouch]); // Effect to handle drag start
  // time threshold for touch
  // start event.

  React.useEffect(function () {
    if (!dragTouchActive) return; // Store timeout in variable
    // for cleanup.

    var timeout = setTimeout(handleDragStartTouch, dragTouchTimeThreshold, dragTouchEvent);
    return function () {
      return clearTimeout(timeout);
    };
  }, [dragTouchActive, dragTouchEvent, dragTouchTimeThreshold, handleDragStartTouch]); // Get event listener 
  // registration from 
  // context.

  var context = useBuilderContext();
  var events = context.events;
  var handleDragOver = useEventCallback(function (event) {
    reactRedux.batch(function () {
      return onDragOver(event);
    });
  });
  var handleDragEnter = useEventCallback(function (event) {
    reactRedux.batch(function () {
      return onDragEnter(event);
    });
  });
  var handleDragLeave = useEventCallback(function (event) {
    reactRedux.batch(function () {
      return onDragLeave(event);
    });
  });
  var handleDragIn = useEventCallback(function (event) {
    reactRedux.batch(function () {
      return onDragIn(event);
    });
  });
  var handleDragOut = useEventCallback(function (event) {
    reactRedux.batch(function () {
      return onDragOut(event);
    });
  });
  var handleDrop = useEventCallback(function (event) {
    reactRedux.batch(function () {
      return onDrop(event);
    });
  }); // Effect to register event
  // handlers to document.

  React.useEffect(function () {
    if (!isDragging) return;
    var ref = box.current;
    if (onDragOver) events.addEventListener(ref, 'dragover', handleDragOver);
    if (onDragEnter) events.addEventListener(ref, 'dragenter', handleDragEnter);
    if (onDragLeave) events.addEventListener(ref, 'dragleave', handleDragLeave);
    if (onDragIn) events.addEventListener(ref, 'dragin', handleDragIn);
    if (onDragOut) events.addEventListener(ref, 'dragout', handleDragOut);
    if (onDrop) events.addEventListener(ref, 'drop', handleDrop);
    return function () {
      if (onDragOver && ref) events.removeEventListener(ref, 'dragover', handleDragOver);
      if (onDragEnter && ref) events.removeEventListener(ref, 'dragenter', handleDragEnter);
      if (onDragLeave && ref) events.removeEventListener(ref, 'dragleave', handleDragLeave);
      if (onDragIn && ref) events.removeEventListener(ref, 'dragin', handleDragIn);
      if (onDragOut && ref) events.removeEventListener(ref, 'dragout', handleDragOut);
      if (onDrop && ref) events.removeEventListener(ref, 'drop', handleDrop);
    };
  }, [events, box, onDragOver, onDragEnter, onDragLeave, onDragIn, onDragOut, onDrop, handleDragOver, handleDragEnter, handleDragLeave, handleDragIn, handleDragOut, handleDrop, isDragging]); // Render with 'as' props 

  var Component = as;
  return /*#__PURE__*/React__default['default'].createElement(Component, _extends__default['default']({}, rest, {
    ref: box
  }));
});

var DnDListener = /*#__PURE__*/React__default['default'].forwardRef(function DnDListener(_ref, ref) {
  var _ref$listenAny = _ref.listenAny,
      listenAny = _ref$listenAny === void 0 ? false : _ref$listenAny,
      listenTransferType = _ref.listenTransferType,
      props = _objectWithoutProperties__default['default'](_ref, ["listenAny", "listenTransferType"]);

  // Component to decouple
  // builder logic from drag
  // and drop source's logic
  var selector = function selector(store) {
    return getTransfer(store);
  };

  var transfer = reactRedux.useSelector(selector);
  var transferData = getTransferData(transfer);
  var transferType = getTransferType(transfer);
  var isType = listenAny || listenTransferType === transferType;
  var isDragging = transferData && isType;
  return /*#__PURE__*/React__default['default'].createElement(DnDSource, _extends__default['default']({}, props, {
    ref: ref,
    isDragging: isDragging
  }));
});

var DnDBuilder = /*#__PURE__*/React__default['default'].forwardRef(function DnDBuilder(_ref, ref) {
  var props = _extends__default['default']({}, _ref);

  // Listen to builder
  // drag and drop operations
  // only
  return /*#__PURE__*/React__default['default'].createElement(DnDListener, _extends__default['default']({}, props, {
    ref: ref,
    listenTransferType: "builder"
  }));
});

var DnDBuilderHOC = function DnDBuilderHOC(Component) {
  return /*#__PURE__*/React.forwardRef(function DnDBuilderHOC(props, ref) {
    return /*#__PURE__*/React__default['default'].createElement(DnDBuilder, _extends__default['default']({
      ref: ref,
      as: Component
    }, props));
  });
};

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var selectMultipleById = function selectMultipleById() {
  for (var _len = arguments.length, id = new Array(_len), _key = 0; _key < _len; _key++) {
    id[_key] = arguments[_key];
  }

  return function (store) {
    return getMultipleById.apply(void 0, [getTree(store)].concat(id));
  };
};

var selectMultipleByIndex = function selectMultipleByIndex(index) {
  return function (store) {
    return getMultipleByIndex(getTree(store), index);
  };
};

var selectMultipleByFilter = function selectMultipleByFilter(filter) {
  return function (store) {
    return getMultipleByFilter(getTree(store), filter);
  };
};

var selectMultipleByFinder = function selectMultipleByFinder(finder) {
  return function (store) {
    return getMultipleByFinder(getTree(store), finder);
  };
};

var selectParents = function selectParents(id) {
  return function (store) {
    return getParentsById(getTree(store), id);
  };
};

var selectChildren = function selectChildren(id) {
  return function (store) {
    return getChildrenById(getTree(store), id);
  };
};

var selectDirectChildren = function selectDirectChildren(id) {
  return function (store) {
    return getDirectChildrenById(getTree(store), id);
  };
};

var useMultiCollector = function useMultiCollector(_ref) {
  var _ref$selector = _ref.selector,
      selector = _ref$selector === void 0 ? function () {} : _ref$selector;
  var selectors = {
    selectMultipleById: selectMultipleById,
    selectMultipleByIndex: selectMultipleByIndex,
    selectMultipleByFilter: selectMultipleByFilter,
    selectMultipleByFinder: selectMultipleByFinder,
    selectParents: selectParents,
    selectChildren: selectChildren,
    selectDirectChildren: selectDirectChildren
  };
  var chosen = selector(selectors);
  var nodes = reactRedux.useSelector(chosen, reactRedux.shallowEqual);

  function listIds() {
    return keys(nodes);
  }

  function listNodes() {
    return values(nodes);
  }

  var metaSelector = function metaSelector(store) {
    return getMultipleMetaById.apply(void 0, [getTree(store)].concat(_toConsumableArray__default['default'](listIds())));
  };

  var meta = reactRedux.useSelector(metaSelector, reactRedux.shallowEqual);

  function listMeta() {
    return values(meta);
  }

  var indexSelector = function indexSelector(store) {
    return getMultipleIndexesForId.apply(void 0, [getTree(store)].concat(_toConsumableArray__default['default'](listIds())));
  };

  var indexing = reactRedux.useSelector(indexSelector, reactRedux.shallowEqual);
  var handler = {
    get: function get(target, name) {
      return target.includes(name);
    }
  };
  var indexes = listIds().reduce(function (indexes, id) {
    indexes[id] = new Proxy(indexing[id], handler);
    return indexes;
  }, {});
  var collectorBag = {
    nodes: nodes,
    meta: meta,
    indexes: indexes
  };
  var utils = {
    listIds: listIds,
    listNodes: listNodes,
    listMeta: listMeta
  };

  var bag = _objectSpread$9(_objectSpread$9({}, collectorBag), utils);

  return bag;
};

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useCreator = function useCreator() {
  var dispatch = reactRedux.useDispatch(); // Not creating an unbatched 
  // version for create since
  // create actions must be 
  // registered on a single history
  // version.

  function handleCreateBatched(creation) {
    var branch = creation.node;
    var node = plainBranch(branch);
    dispatch(createNodeBatched({
      node: node,
      targetId: creation.targetId,
      position: creation.position
    }));
    dispatch(createMetaBatched({
      meta: node.meta
    }));
    dispatch(createIndexBatched({
      index: node.index,
      index_list: node.index_list
    }));
  }

  function handleCreateUnrecorded(creation) {
    var branch = creation.node;
    var node = plainBranch(branch);
    dispatch(createNodeUnrecorded({
      node: node,
      targetId: creation.targetId,
      position: creation.position
    }));
    dispatch(createMetaUnrecorded({
      meta: node.meta
    }));
    dispatch(createIndexUnrecorded({
      index: node.index,
      index_list: node.index_list
    }));
  }

  var handlers = {
    handleCreateBatched: handleCreateBatched,
    handleCreateUnrecorded: handleCreateUnrecorded
  };
  var creatorBag = {};

  var bag = _objectSpread$8(_objectSpread$8({}, creatorBag), handlers);

  return bag;
};

var useDeleter = function useDeleter() {
  var dispatch = reactRedux.useDispatch(); // Not creating an unbatched 
  // version for delete since
  // delete actions must be 
  // registered on a single history
  // version.

  function handleDeleteBatched(deletion) {
    var id = deletion.id;
    dispatch(deleteMetaBatched({
      id: id
    }));
    dispatch(deleteIndexBatched({
      id: id
    })); // Delete node dispatch should
    // ALWAYS be last to allow before
    // delete dispatches to access 
    // node children.

    dispatch(deleteNodeBatched({
      id: id
    }));
  }

  function handleDeleteUnrecorded(deletion) {
    var id = deletion.id;
    dispatch(deleteMetaUnrecorded({
      id: id
    }));
    dispatch(deleteIndexUnrecorded({
      id: id
    })); // Delete node is last.

    dispatch(deleteNodeUnrecorded({
      id: id
    }));
  }

  var handlers = {
    handleDeleteBatched: handleDeleteBatched,
    handleDeleteUnrecorded: handleDeleteUnrecorded
  };
  var deleterBag = {};

  var bag = _objectSpread$8(_objectSpread$8({}, deleterBag), handlers);

  return bag;
};

var useReplacer = function useReplacer() {
  var dispatch = reactRedux.useDispatch();

  function handleReplace(replace) {
    var branch = replace.tree;
    var tree = plainBranch(branch);
    dispatch(replaceTreeUnrecorded({
      tree: tree
    })); // Restart history after
    // replacing tree since
    // tree replacement should 
    // not be recorded in history.

    dispatch(restartHistory());
  }

  var handlers = {
    handleReplace: handleReplace
  };
  var replacerBag = {};

  var bag = _objectSpread$8(_objectSpread$8({}, replacerBag), handlers);

  return bag;
};

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useActions = function useActions() {
  var dispatch = reactRedux.useDispatch();
  var context = useBuilderContext();
  var batcher = context.batcher;
  var creator = useCreator();
  var deleter = useDeleter(); // Payload extractors

  var movePayload = function movePayload(move) {
    return {
      targetId: move.targetId,
      id: move.id,
      position: move.position
    };
  };

  var shiftPayload = function shiftPayload(shift) {
    return {
      id: shift.id,
      absolute: shift.absolute,
      relative: shift.relative
    };
  };

  var updatePayload = function updatePayload(update) {
    var props = update.props;

    var _props = Object.keys(props).reduce(function (update, prop) {
      return setIn(update, prop, props[prop]);
    }, {});

    return {
      id: update.id,
      props: _props
    };
  };

  var rewritePayload = function rewritePayload(rewrite) {
    var props = rewrite.props;

    var _props = Object.keys(props).reduce(function (update, prop) {
      return setIn(update, prop, props[prop]);
    }, {});

    return {
      id: rewrite.id,
      props: _props
    };
  };

  var metaUpdatePayload = function metaUpdatePayload(update) {
    var meta = update.meta;

    var _meta = Object.keys(meta).reduce(function (update, prop) {
      return setIn(update, prop, meta[prop]);
    }, {});

    return {
      id: update.id,
      meta: _meta
    };
  };

  var indexAddPayload = function indexAddPayload(add) {
    return {
      id: add.id,
      name: add.name
    };
  };

  var listIndexAddPayload = function listIndexAddPayload(add) {
    return {
      id: add.id,
      name: add.name
    };
  };

  var indexRemovePayload = function indexRemovePayload(remove) {
    return {
      id: remove.id,
      name: remove.name
    };
  };

  var listIndexRemovePayload = function listIndexRemovePayload(remove) {
    return {
      id: remove.id,
      name: remove.name
    };
  };

  var indexTogglePayload = function indexTogglePayload(toggle) {
    return {
      id: toggle.id,
      name: toggle.name
    };
  };

  var listIndexTogglePayload = function listIndexTogglePayload(toggle) {
    return {
      id: toggle.id,
      name: toggle.name
    };
  };

  var indexClearPayload = function indexClearPayload(clear) {
    return {
      name: clear.name
    };
  };

  var listIndexClearPayload = function listIndexClearPayload(clear) {
    return {
      name: clear.name
    };
  }; // Time batched actions


  function triggerCreateTimeBatched(create) {
    creator.handleCreateBatched(create);
    batcher.refresh();
  }

  function triggerDeleteTimeBatched(deleted) {
    deleter.handleDeleteBatched(deleted);
    batcher.refresh();
  }

  function triggerMoveTimeBatched(move) {
    dispatch(moveNodeBatched(movePayload(move)));
    batcher.refresh();
  }

  function triggerShiftTimeBatched(shift) {
    dispatch(intershiftNodeBatched(shiftPayload(shift)));
    batcher.refresh();
  }

  function triggerUpdateTimeBatched(update) {
    dispatch(updateNodeBatched(updatePayload(update)));
    batcher.refresh();
  }

  function triggerRewriteTimeBatched(rewrite) {
    dispatch(rewriteNodeBatched(rewritePayload(rewrite)));
    batcher.refresh();
  }

  function triggerMetaUpdateTimeBatched(update) {
    dispatch(updateMetaBatched(metaUpdatePayload(update)));
    batcher.refresh();
  }

  function triggerIndexAddTimeBatched(add) {
    dispatch(addIndexBatched(indexAddPayload(add)));
    batcher.refresh();
  }

  function triggerListIndexAddTimeBatched(add) {
    dispatch(addListIndexBatched(listIndexAddPayload(add)));
    batcher.refresh();
  }

  function triggerIndexRemoveTimeBatched(remove) {
    dispatch(removeIndexBatched(indexRemovePayload(remove)));
    batcher.refresh();
  }

  function triggerListIndexRemoveTimeBatched(remove) {
    dispatch(removeListIndexBatched(listIndexRemovePayload(remove)));
    batcher.refresh();
  }

  function triggerIndexToggleTimeBatched(toggle) {
    dispatch(toggleIndexBatched(indexTogglePayload(toggle)));
    batcher.refresh();
  }

  function triggerListIndexToggleTimeBatched(toggle) {
    dispatch(toggleListIndexBatched(listIndexTogglePayload(toggle)));
    batcher.refresh();
  }

  function triggerIndexClearTimeBatched(clear) {
    dispatch(clearIndexBatched(indexClearPayload(clear)));
    batcher.refresh();
  }

  function triggerListIndexClearTimeBatched(clear) {
    dispatch(clearListIndexBatched(listIndexClearPayload(clear)));
    batcher.refresh();
  } // Batched actions


  function triggerCreateBatched(create) {
    batcher.abort();
    creator.handleCreateBatched(create);
  }

  function triggerDeleteBatched(deleted) {
    batcher.abort();
    deleter.handleDeleteBatched(deleted);
  }

  function triggerMoveBatched(move) {
    batcher.abort();
    dispatch(moveNodeBatched(movePayload(move)));
  }

  function triggerShiftBatched(shift) {
    batcher.abort();
    dispatch(intershiftNodeBatched(shiftPayload(shift)));
  }

  function triggerUpdateBatched(update) {
    batcher.abort();
    dispatch(updateNodeBatched(updatePayload(update)));
  }

  function triggerRewriteBatched(rewrite) {
    batcher.abort();
    dispatch(rewriteNodeBatched(rewritePayload(rewrite)));
  }

  function triggerMetaUpdateBatched(update) {
    batcher.abort();
    dispatch(updateMetaBatched(metaUpdatePayload(update)));
  }

  function triggerIndexAddBatched(add) {
    batcher.abort();
    dispatch(addIndexBatched(indexAddPayload(add)));
  }

  function triggerListIndexAddBatched(add) {
    batcher.abort();
    dispatch(addListIndexBatched(listIndexAddPayload(add)));
  }

  function triggerIndexRemoveBatched(remove) {
    batcher.abort();
    dispatch(removeIndexBatched(indexRemovePayload(remove)));
  }

  function triggerListIndexRemoveBatched(remove) {
    batcher.abort();
    dispatch(removeListIndexBatched(listIndexRemovePayload(remove)));
  }

  function triggerIndexToggleBatched(toggle) {
    batcher.abort();
    dispatch(toggleIndexBatched(indexTogglePayload(toggle)));
  }

  function triggerListIndexToggleBatched(toggle) {
    batcher.abort();
    dispatch(toggleListIndexBatched(listIndexTogglePayload(toggle)));
  }

  function triggerIndexClearBatched(clear) {
    batcher.abort();
    dispatch(clearIndexBatched(indexClearPayload(clear)));
  }

  function triggerListIndexClearBatched(clear) {
    batcher.abort();
    dispatch(clearListIndexBatched(listIndexClearPayload(clear)));
  } // Unbatched actions


  function triggerCreateUnbatched(create) {
    batcher.abort();
    creator.handleCreateBatched(create); // Dispatch commit history
    // directly after batching
    // create actions to simulate
    // unbatched action.

    dispatch(commitHistory({}));
  }

  function triggerDeleteUnbatched(deleted) {
    batcher.abort();
    deleter.handleDeleteBatched(deleted); // Dispatch commit history
    // directly after batching
    // delete actions to simulate
    // unbatched action.

    dispatch(commitHistory({}));
  }

  function triggerMoveUnbatched(move) {
    batcher.abort();
    dispatch(moveNodeUnbatched(movePayload(move)));
  }

  function triggerShiftUnbatched(shift) {
    batcher.abort();
    dispatch(intershiftNodeUnbatched(shiftPayload(shift)));
  }

  function triggerUpdateUnbatched(update) {
    batcher.abort();
    dispatch(updateNodeUnbatched(updatePayload(update)));
  }

  function triggerRewriteUnbatched(rewrite) {
    batcher.abort();
    dispatch(rewriteNodeUnbatched(rewritePayload(rewrite)));
  }

  function triggerMetaUpdateUnbatched(update) {
    batcher.abort();
    dispatch(updateMetaUnbatched(metaUpdatePayload(update)));
  }

  function triggerIndexAddUnbatched(add) {
    batcher.abort();
    dispatch(addIndexUnbatched(indexAddPayload(add)));
  }

  function triggerListIndexAddUnbatched(add) {
    batcher.abort();
    dispatch(addListIndexUnbatched(listIndexAddPayload(add)));
  }

  function triggerIndexRemoveUnbatched(remove) {
    batcher.abort();
    dispatch(removeIndexUnbatched(indexRemovePayload(remove)));
  }

  function triggerListIndexRemoveUnbatched(remove) {
    batcher.abort();
    dispatch(removeListIndexUnbatched(listIndexRemovePayload(remove)));
  }

  function triggerIndexToggleUnbatched(toggle) {
    batcher.abort();
    dispatch(toggleIndexUnbatched(indexTogglePayload(toggle)));
  }

  function triggerListIndexToggleUnbatched(toggle) {
    batcher.abort();
    dispatch(toggleListIndexUnbatched(listIndexTogglePayload(toggle)));
  }

  function triggerIndexClearUnbatched(clear) {
    batcher.abort();
    dispatch(clearIndexUnbatched(indexClearPayload(clear)));
  }

  function triggerListIndexClearUnbatched(clear) {
    batcher.abort();
    dispatch(clearListIndexUnbatched(listIndexClearPayload(clear)));
  } // Unrecorded actions


  function triggerCreateUnrecorded(create) {
    creator.handleCreateUnrecorded(create);
  }

  function triggerDeleteUnrecorded(deleted) {
    deleter.handleDeleteUnrecorded(deleted);
  }

  function triggerMoveUnrecorded(move) {
    dispatch(moveNodeUnrecorded(movePayload(move)));
  }

  function triggerShiftUnrecorded(shift) {
    dispatch(intershiftNodeUnrecorded(shiftPayload(shift)));
  }

  function triggerUpdateUnrecorded(update) {
    dispatch(updateNodeUnrecorded(updatePayload(update)));
  }

  function triggerRewriteUnrecorded(rewrite) {
    dispatch(rewriteNodeUnrecorded(rewritePayload(rewrite)));
  }

  function triggerMetaUpdateUnrecorded(update) {
    dispatch(updateMetaUnrecorded(metaUpdatePayload(update)));
  }

  function triggerIndexAddUnrecorded(add) {
    dispatch(addIndexUnrecorded(indexAddPayload(add)));
  }

  function triggerListIndexAddUnrecorded(add) {
    dispatch(addListIndexUnrecorded(listIndexAddPayload(add)));
  }

  function triggerIndexRemoveUnrecorded(remove) {
    dispatch(removeIndexUnrecorded(indexRemovePayload(remove)));
  }

  function triggerListIndexRemoveUnrecorded(remove) {
    dispatch(removeListIndexUnrecorded(listIndexRemovePayload(remove)));
  }

  function triggerIndexToggleUnrecorded(toggle) {
    dispatch(toggleIndexUnrecorded(indexTogglePayload(toggle)));
  }

  function triggerListIndexToggleUnrecorded(toggle) {
    dispatch(toggleListIndexUnrecorded(listIndexTogglePayload(toggle)));
  }

  function triggerIndexClearUnrecorded(clear) {
    dispatch(clearIndexUnrecorded(indexClearPayload(clear)));
  }

  function triggerListIndexClearUnrecorded(clear) {
    dispatch(clearListIndexUnrecorded(listIndexClearPayload(clear)));
  } // History actions


  function triggerCommit() {
    batcher.abort();
    dispatch(commitHistory({}));
  }

  var timeBatched = {
    triggerCreate: triggerCreateTimeBatched,
    triggerDelete: triggerDeleteTimeBatched,
    triggerMove: triggerMoveTimeBatched,
    triggerShift: triggerShiftTimeBatched,
    triggerUpdate: triggerUpdateTimeBatched,
    triggerRewrite: triggerRewriteTimeBatched,
    triggerMetaUpdate: triggerMetaUpdateTimeBatched,
    triggerIndexAdd: triggerIndexAddTimeBatched,
    triggerIndexRemove: triggerIndexRemoveTimeBatched,
    triggerIndexToggle: triggerIndexToggleTimeBatched,
    triggerIndexClear: triggerIndexClearTimeBatched,
    triggerListIndexAdd: triggerListIndexAddTimeBatched,
    triggerListIndexRemove: triggerListIndexRemoveTimeBatched,
    triggerListIndexToggle: triggerListIndexToggleTimeBatched,
    triggerListIndexClear: triggerListIndexClearTimeBatched
  };
  var batched = {
    triggerCreate: triggerCreateBatched,
    triggerDelete: triggerDeleteBatched,
    triggerMove: triggerMoveBatched,
    triggerShift: triggerShiftBatched,
    triggerUpdate: triggerUpdateBatched,
    triggerRewrite: triggerRewriteBatched,
    triggerMetaUpdate: triggerMetaUpdateBatched,
    triggerIndexAdd: triggerIndexAddBatched,
    triggerIndexRemove: triggerIndexRemoveBatched,
    triggerIndexToggle: triggerIndexToggleBatched,
    triggerIndexClear: triggerIndexClearBatched,
    triggerListIndexAdd: triggerListIndexAddBatched,
    triggerListIndexRemove: triggerListIndexRemoveBatched,
    triggerListIndexToggle: triggerListIndexToggleBatched,
    triggerListIndexClear: triggerListIndexClearBatched
  };
  var unbatched = {
    triggerCreate: triggerCreateUnbatched,
    triggerDelete: triggerDeleteUnbatched,
    triggerMove: triggerMoveUnbatched,
    triggerShift: triggerShiftUnbatched,
    triggerUpdate: triggerUpdateUnbatched,
    triggerRewrite: triggerRewriteUnbatched,
    triggerMetaUpdate: triggerMetaUpdateUnbatched,
    triggerIndexAdd: triggerIndexAddUnbatched,
    triggerIndexRemove: triggerIndexRemoveUnbatched,
    triggerIndexToggle: triggerIndexToggleUnbatched,
    triggerIndexClear: triggerIndexClearUnbatched,
    triggerListIndexAdd: triggerListIndexAddUnbatched,
    triggerListIndexRemove: triggerListIndexRemoveUnbatched,
    triggerListIndexToggle: triggerListIndexToggleUnbatched,
    triggerListIndexClear: triggerListIndexClearUnbatched
  };
  var unrecorded = {
    triggerCreate: triggerCreateUnrecorded,
    triggerDelete: triggerDeleteUnrecorded,
    triggerMove: triggerMoveUnrecorded,
    triggerShift: triggerShiftUnrecorded,
    triggerUpdate: triggerUpdateUnrecorded,
    triggerRewrite: triggerRewriteUnrecorded,
    triggerMetaUpdate: triggerMetaUpdateUnrecorded,
    triggerIndexAdd: triggerIndexAddUnrecorded,
    triggerIndexRemove: triggerIndexRemoveUnrecorded,
    triggerIndexToggle: triggerIndexToggleUnrecorded,
    triggerIndexClear: triggerIndexClearUnrecorded,
    triggerListIndexAdd: triggerListIndexAddUnrecorded,
    triggerListIndexRemove: triggerListIndexRemoveUnrecorded,
    triggerListIndexToggle: triggerListIndexToggleUnrecorded,
    triggerListIndexClear: triggerListIndexClearUnrecorded
  };
  var history = {
    triggerCommit: triggerCommit
  };
  var triggers = {
    timeBatched: timeBatched,
    batched: batched,
    unbatched: unbatched,
    unrecorded: unrecorded,
    history: history
  };

  var bag = _objectSpread$7({}, triggers);

  return bag;
};

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useDnD = function useDnD(_ref) {
  var initialTransferType = _ref.initialTransferType;

  var _useState = React.useState(initialTransferType),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      transferType = _useState2[0],
      setTransferType = _useState2[1];

  var dispatch = reactRedux.useDispatch();

  function triggerDragStart(drag) {
    dispatch(startTransfer({
      data: drag.data,
      meta: drag.meta,
      type: transferType
    }));
  }

  function triggerDragStartMove(drag) {
    var meta = _objectSpread$6({
      create: false
    }, drag.meta || {});

    triggerDragStart({
      data: drag.data,
      meta: meta,
      type: transferType
    });
  }

  function triggerDragStartCreate(drag) {
    var meta = _objectSpread$6({
      create: true
    }, drag.meta || {});

    triggerDragStart({
      data: drag.data,
      meta: meta,
      type: transferType
    });
  }

  function triggerDragEnd() {
    dispatch(endTransfer({}));
  }

  var dndBag = {
    transferType: transferType,
    setTransferType: setTransferType
  };
  var triggers = {
    triggerDragStartCreate: triggerDragStartCreate,
    triggerDragStartMove: triggerDragStartMove,
    triggerDragEnd: triggerDragEnd
  };

  var bag = _objectSpread$6(_objectSpread$6({}, dndBag), triggers);

  return bag;
};

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useDnDHelpers = function useDnDHelpers(params) {
  var transferSelector = function transferSelector(store) {
    return getTransfer(store);
  };

  var transfer = reactRedux.useSelector(transferSelector);
  var events = useEventHelpers();

  function getDnDEventClientCoords(event) {
    return events.getEventClientCoords(event);
  }

  function getDnDEventPosition(event) {
    return events.getEventPosition(event);
  }

  function getDragAndDrop() {
    var data = getTransferData(transfer); // In case drop is not
    // caused by an internal
    // action, such as dropping
    // a file or image. Or when
    // there is no active current
    // drag and drop action.

    if (!data) return null;
    var meta = getTransferMeta(transfer);
    var create = meta.create;
    if (create) return getDragAndDropCreate();else return getDragAndDropMove();
  }

  function getDragAndDropCreate() {
    var data = getTransferData(transfer);
    var meta = getTransferMeta(transfer);
    var rootId = data.root;
    var root = data.byIds[rootId];
    var bagDnD = {
      transfer: root,
      meta: meta
    };
    return bagDnD;
  }

  function getDragAndDropMove() {
    var moved = getTransferData(transfer);
    var meta = getTransferMeta(transfer);
    var bagDnD = {
      transfer: moved,
      meta: meta
    };
    return bagDnD;
  }

  var isTransfering = Boolean(transfer.data);
  var transferType = params && params.transferType;
  var isTransferingType = isTransfering && transfer.type === transferType;
  var flags = {
    isTransfering: isTransfering,
    isTransferingType: isTransferingType
  };
  var utils = {
    getDnDEventPosition: getDnDEventPosition,
    getDnDEventClientCoords: getDnDEventClientCoords,
    getDragAndDrop: getDragAndDrop
  };

  var bag = _objectSpread$5(_objectSpread$5({}, flags), utils);

  return bag;
};

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useNodeDnD = function useNodeDnD(_ref) {
  var id = _ref.id,
      initialTransferType = _ref.initialTransferType;
  // Warn client if a falsy
  // id was received, as this
  // will cause unpredictable 
  // behavior.
  React.useEffect(function () {
    if (id) return;
    console.warn("\n            Did not received valid \n            id in DnD hook. \n            Please provide a valid\n            id to have predictable \n            behavior.\n        ");
  }, [id]);

  var nodeSelector = function nodeSelector(selectors) {
    return selectors.selectById(id);
  };

  var collect = useCollector({
    selector: nodeSelector
  });
  var node = collect.node;

  var multiSelector = function multiSelector(selectors) {
    return selectors.selectParents(id);
  };

  var multicollect = useMultiCollector({
    selector: multiSelector
  });
  var nodeParents = multicollect.nodes;

  var transferSelector = function transferSelector(store) {
    return getTransfer(store);
  };

  var transfer = reactRedux.useSelector(transferSelector);
  var dnd = useDnD({
    initialTransferType: initialTransferType
  });
  var transferType = dnd.transferType;
  var helpers = useDnDHelpers({
    transferType: transferType
  });
  var actions = useActions();

  function triggerDragStart(drag) {
    dnd.triggerDragStartMove({
      data: node,
      meta: drag.meta // Transfer type
      // set by DnD hook
      // composition

    });
  }

  function triggerDragEnd() {
    dnd.triggerDragEnd();
  }

  function handleDragStart(event) {
    triggerDragStart({});
    event.stopPropagation();
  }

  function handleDragEnd() {
    triggerDragEnd();
  }

  function handleDrop(event) {
    var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var data = getTransferData(transfer); // In case drop is not
    // caused by an internal
    // action, such as dropping
    // a file or image.

    if (!data) return;
    var meta = getTransferMeta(transfer);
    var create = meta.create;
    if (create) handleDropCreate(event, position);
    if (!create) handleDropMove(event, position);
  }

  function handleDropCreate(event, position) {
    var data = getTransferData(transfer);
    actions.timeBatched.triggerCreate({
      targetId: id,
      node: data,
      position: position
    });
    event.stopPropagation();
  }

  function handleDropMove(event, position) {
    var data = getTransferData(transfer);
    actions.timeBatched.triggerMove({
      id: data.id,
      targetId: id,
      position: position
    });
    event.stopPropagation();
  }

  function handleChildYDrop(event, position) {
    var _helpers$getDnDEventP = helpers.getDnDEventPosition(event),
        top = _helpers$getDnDEventP.top;

    var offset = top ? 0 : 1;
    var dropPosition = position + offset;
    handleDrop(event, dropPosition);
  }

  function handleChildXDrop(event, position) {
    var _helpers$getDnDEventP2 = helpers.getDnDEventPosition(event),
        left = _helpers$getDnDEventP2.left;

    var offset = left ? 0 : 1;
    var dropPosition = position + offset;
    handleDrop(event, dropPosition);
  }

  function toDnDHandler(handler) {
    // Must wrap handlers with
    // this function to avoid
    // handling unwanted events,
    // such as "recursive" dnd
    // events, like dropping
    // a component into itself.
    var bag = helpers.getDragAndDrop();

    if (!bag) {
      return handler;
    }

    var transferID = bag.transfer.id;
    var isRecursive = nodeParents[transferID] || transferID === id;

    if (!isRecursive) {
      return handler;
    } // Ignore handler if
    // transfer node is 
    // invalid.


    return undefined;
  }

  var dndBag = {
    transferType: dnd.transferType,
    setTransferType: dnd.setTransferType
  };
  var handlers = {
    handleDrop: toDnDHandler(handleDrop),
    handleChildXDrop: toDnDHandler(handleChildXDrop),
    handleChildYDrop: toDnDHandler(handleChildYDrop),
    handleDragStart: handleDragStart,
    handleDragEnd: handleDragEnd
  };
  var triggers = {
    triggerDragStart: triggerDragStart,
    triggerDragEnd: triggerDragEnd
  };
  var wrappers = {
    toDnDHandler: toDnDHandler
  };

  var bag = _objectSpread$4(_objectSpread$4(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, dndBag), handlers), triggers), helpers), wrappers);

  return bag;
};

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useEditor = function useEditor(_ref) {
  var id = _ref.id;
  // Warn client if a falsy
  // id was received, as this
  // will cause unpredictable 
  // behavior.
  React.useEffect(function () {
    if (id) return;
    console.warn("\n            Did not received valid \n            id in editor hook. \n            Please provide a valid\n            id to have predictable \n            behavior.\n        ");
  }, [id]);

  var nodeSelector = function nodeSelector(selectors) {
    return selectors.selectById(id);
  };

  var collected = useCollector({
    selector: nodeSelector
  });
  var props = collected.node && collected.node.props;
  var meta = collected.meta;
  var dnd = useNodeDnD({
    initialTransferType: 'builder',
    id: id
  });
  var actions = useActions();

  function getEventValue(event) {
    var target = event.target;
    var type = target.type;
    var value = target.value;
    var checked = target.checked;

    switch (type) {
      case 'checkbox':
        {
          return checked;
        }

      case 'number':
      case 'range':
        {
          var number = parseNumber(value);
          return isNumber(number) ? number : value;
        }

      default:
        {
          return value;
        }
    }
  }

  function handleUpdate(event, parser) {
    var name = event.target.name;
    var value = getEventValue(event);
    var previousValue = getIn(props, name);
    var parsedValue = parser && isFunction$1(parser) ? parser(value, previousValue) : value;
    var props = setIn({}, name, parsedValue);
    actions.timeBatched.triggerUpdate({
      id: id,
      props: props
    });
  }

  function handleMetaUpdate(event, parser) {
    var name = event.target.name;
    var value = getEventValue(event);
    var previousValue = getIn(meta, name);
    var parsedValue = parser && isFunction$1(parser) ? parser(value, previousValue) : value;
    var props = setIn({}, name, parsedValue);
    actions.timeBatched.triggerMetaUpdate({
      id: id,
      meta: props
    });
  }

  function handlePanel(event) {
    event.stopPropagation(); // Trigger index change

    actions.timeBatched.triggerIndexAdd({
      id: id,
      name: 'panel'
    });
  }

  var editorBag = {
    props: props,
    meta: meta
  };

  dnd.isTransfering;
      var isTransferingType = dnd.isTransferingType;
      dnd.transferType;
      dnd.setTransferType;
      var dndBag = _objectWithoutProperties__default['default'](dnd, ["isTransfering", "isTransferingType", "transferType", "setTransferType"]);

  var handlers = {
    handleUpdate: handleUpdate,
    handleMetaUpdate: handleMetaUpdate,
    handlePanel: handlePanel
  };
  var flags = {
    isTransfering: isTransferingType
  };

  var bag = _objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3({}, editorBag), dndBag), handlers), flags);

  return bag;
};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useToolDnD = function useToolDnD(_ref) {
  var initialTransferType = _ref.initialTransferType;
  var dnd = useDnD({
    initialTransferType: initialTransferType
  });
  var transferType = dnd.transferType;
  var setTransferType = dnd.setTransferType;

  function triggerDragStart(drag) {
    var data = plainBranch(drag.data);
    dnd.triggerDragStartCreate({
      data: data,
      meta: drag.meta
    });
  }

  function triggerDragEnd() {
    dnd.triggerDragEnd();
  }

  function handleDragEnd() {
    triggerDragEnd();
  }

  var dndBag = {
    transferType: transferType,
    setTransferType: setTransferType
  };
  var handlers = {
    handleDragEnd: handleDragEnd
  };
  var triggers = {
    triggerDragStart: triggerDragStart,
    triggerDragEnd: triggerDragEnd
  };

  var bag = _objectSpread$2(_objectSpread$2(_objectSpread$2({}, dndBag), handlers), triggers);

  return bag;
};

var useTools = function useTools() {
  var dnd = useToolDnD({
    initialTransferType: 'builder'
  });

  dnd.transferType;
      dnd.setTransferType;
      var bag = _objectWithoutProperties__default['default'](dnd, ["transferType", "setTransferType"]);

  return bag;
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useVersion = function useVersion() {
  var dispatch = reactRedux.useDispatch();
  var history = reactRedux.useSelector(getTreeHistory);
  var context = useBuilderContext();
  var batcher = context.batcher; // console.log(history);

  function handleUndo() {
    batcher.abort();
    dispatch(undoHistory({}));
  }

  function handleRedo() {
    batcher.abort();
    dispatch(redoHistory({}));
  }

  var redoSelector = function redoSelector(store) {
    return getCanRedo(getTreeSlice(store));
  };

  var canRedo = reactRedux.useSelector(redoSelector, reactRedux.shallowEqual);

  var undoSelector = function undoSelector(store) {
    return getCanUndo(getTreeSlice(store));
  };

  var canUndo = reactRedux.useSelector(undoSelector, reactRedux.shallowEqual);
  var historyBag = {
    history: history,
    canUndo: canUndo,
    canRedo: canRedo
  };
  var handlers = {
    handleUndo: handleUndo,
    handleRedo: handleRedo
  };

  var bag = _objectSpread$1(_objectSpread$1({}, historyBag), handlers);

  return bag;
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var useBuilder = function useBuilder() {
  var version = useVersion();
  var replacer = useReplacer();
  var tree = getTreeFromHistory(version.history);
  var context = useBuilderContext();
  var batcher = context.batcher;

  function json() {
    return tree;
  }

  function loadTree(tree) {
    batcher.abort(); // Tree should include
    // tree meta that will
    // be loaded.

    replacer.handleReplace({
      tree: tree
    });
  }

  var builderBag = {};
  var utils = {
    json: json,
    loadTree: loadTree
  };

  var bag = _objectSpread(_objectSpread(_objectSpread({}, builderBag), version), utils);

  return bag;
};

var useView = function useView() {
  var context = React.useContext(ViewContext);
  return context;
};

Object.defineProperty(exports, 'itemid', {
    enumerable: true,
    get: function () {
        return toolkit.nanoid;
    }
});
exports.Builder = Builder;
exports.DnDBuilder = DnDBuilder;
exports.DnDBuilderHOC = DnDBuilderHOC;
exports.DnDListener = DnDListener;
exports.Node = Node;
exports.Panel = Panel;
exports.ViewProvider = ViewProvider;
exports.Workspace = Workspace;
exports.branch = branch;
exports.item = item;
exports.useActions = useActions;
exports.useBuilder = useBuilder;
exports.useCollector = useCollector;
exports.useDnDHelpers = useDnDHelpers;
exports.useEditor = useEditor;
exports.useMultiCollector = useMultiCollector;
exports.useNodeDnD = useNodeDnD;
exports.useToolDnD = useToolDnD;
exports.useTools = useTools;
exports.useView = useView;
